# 12-原生类型赋值给通配符：从失控到受控的转换

**关联代码**：
`ch20_generics/UnboundedWildcards1.java`
`ch20_generics/UnboundedWildcards2.java `

关于将原生 List 赋值给通配符 `List<?>`，我有很深的感悟。首先，原生 List 没有类型参数的约束，编译器没办法对它进行限制，所以写代码时我们可以往里面添加各种各样的东西，任何 Object 都能加进去，这导致它处于一种非常混乱的状态。当然，我们确实可能只添加一种类型，但既然如此，为什么不直接使用泛型类呢？（即将原生类赋值给泛型类引用如 `List<String>`，而不是赋值给通配符 `List<?>`）。

所以，当我们把原生 List 赋值给通配符 List 时，我觉得这个设计非常巧妙。从编译器的角度来讲，它必须做**“最坏的打算”**。因为原生 List 没有约束，我必须假设你里面存的东西是乱七八糟的。虽然你有可能存的是纯净的单类型，但也有可能是一堆杂乱的数据。因此，在**读取**的时候，为了绝对安全，我只能按最差的结果考虑，把你当作 `Object` 来读。不管你里面纯不纯，读出来是 `Object` 肯定是没问题的。

至于**存储**，编译器同样是按最坏的角度去考虑。你原来的原生 List 里可能存了一堆乱七八糟的东西，但当你决定把它赋值给我这个带泛型尖括号的通配符 List 时，情况就变了。虽然通配符代表“什么都可以指向”，但从这一刻起，尖括号的存在就代表你要接受类型的约束。既然你现在的状态很乱，赋值给我之后，我还能拿这个通配符引用去存数据吗？我该存什么呢？因为使用了类型参数，理论上我只能存这个参数指定的类型，可我现在根本没法指定，因为你本身就是乱的。所以没办法，我只能选择**不让你存**。

从理论上推导，我们只能做到这一步。通配符 List 在一定意义上通过了 `Object` 的上界测试，也就是说任何 `Object` 或其子类作为泛型参数都是合法的。但是，我们可以逻辑假设一下：当我们确定了某一种类型（世间万物中的某一个），存取都应该被约束为这一种类型。可惜原生 List 本身是乱的，我只能做一种逻辑上的**形式主义约束**：取的时候，我按最大的上限（`Object`）来取。

这就回到了刚才说的“最坏情况”。你以前是无拘无束的，这种无拘无束可能已经对你本身造成了伤害（里面存得很乱）。现在我们要从原生类型过渡到泛型类型，必须进行约束。在现有的糟糕状态下，怎么约束呢？取的时候只能约到 `Object`。存的时候，我没办法让你存。虽然理论上我这里约束的是 `Object`，似乎应该允许存入 `Object`，但这里是泛型的世界。如果你真的想“什么都能存”，为什么不直接使用 `List<Object>` 呢？我现在使用泛型（通配符）的原因，就是为了约束单个类型。

我并不知道你原来的 List 是纯净的类型，还是极其混乱的类型。**如果我把你当作 `Object` 允许你写入，万一你以前是纯净的呢？我这一写，岂不是进一步造成了破坏？**而如果你以前里面就是乱的（存的 `Object`），那你一开始就应该直接使用 `List<Object>`，而不是用通配符。所以，**封锁写入是唯一的选择**。
