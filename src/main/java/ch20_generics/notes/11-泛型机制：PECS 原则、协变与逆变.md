[TOC]

# 11-泛型机制：PECS 原则、协变与逆变

**关联代码**：
`ch20_generics/SuperTypeWildcards.java`
`ch20_generics/GenericReading.java`

## 1. 概念与术语：PECS

PECS 是 **"Producer Extends, Consumer Super"** 的缩写，这是在 Java 泛型编程中选择通配符类型的指导法则。该原则基于容器在数据流中的角色来确定类型约束：

- **Producer (生产者)**：当容器作为数据的提供者（即从容器中**读取**数据）时，应使用上界通配符 `? extends T`
- **Consumer (消费者)**：当容器作为数据的接收者（即向容器中**写入**数据）时，应使用下界通配符 `? super T`。

---

## 2. 协变性 (Covariance)：上界通配符 (Upper Bounded Wildcard)

**语法定义**：`List<? extends T>`
**术语解析**：此语法体现了**协变性**。`T` 代表类型的**上界 (Upper Bound)**，即该通配符匹配 `T` 及其所有子类型。

### 2.1 引用与运行时类型的关系

声明 `List<? extends Fruit>` 创建了一个引用，该引用指向一个**具体的**、但在编译期**未知的** `Fruit` 子类型的列表。
从内存角度分析，该引用在运行时的底层具体类型（Underlying Concrete Type）可能是 `ArrayList<Apple>`，也可能是 `ArrayList<Banana>`。由于泛型的类型擦除与引用的不确定性，编译器无法在静态检查阶段确定其具体指向哪一个分支。

### 2.2 操作约束分析

- **写入禁止 (Write Prohibition)**：
编译器禁止通过 `? extends` 引用调用任何参数包含泛型类型的方法（如 `add()`），仅允许写入 `null`。
**原理解析**：这是为了防止**堆污染 (Heap Pollution)**。假设引用 `List<? extends Fruit>` 指向的是运行时的 `List<Banana>`，如果编译器允许写入 `Apple`（它也是 Fruit 的子类），则破坏了底层容器的类型完整性。由于无法在编译期确认底层到底是哪种具体的子类容器，编译器必须采取保守策略，禁止所有写入操作。
- **读取允许 (Read Permission)**：
编译器允许读取操作，并将返回类型视为 `T`。
**原理解析**：无论底层具体类型是 `List<Apple>` 还是 `List<Banana>`，其元素在继承树上均属于 `Fruit` 的子类。根据里氏替换原则 (Liskov Substitution Principle)，将其向上转型为 `Fruit` 是绝对安全的。

---

## 3. 逆变性 (Contravariance)：下界通配符 (Lower Bounded Wildcard)

**语法定义**：`List<? super T>`
**术语解析**：此语法体现了**逆变性**。`T` 代表类型的**下界 (Lower Bound)**，即该通配符匹配 `T` 及其所有父类型（直至 `Object`）。

### 3.1 引用与运行时类型的关系

声明 `List<? super Apple>` 创建了一个引用，该引用指向一个**具体的**、但在编译期**未知的** `Apple` 父类型的列表。
从内存角度分析，该引用在运行时的底层具体类型可能是 `ArrayList<Apple>`，`ArrayList<Fruit>`，甚至是 `ArrayList<Object>`。

### 3.2 操作约束分析

- **读取受限 (Read Restriction)**：
通过 `? super` 引用读取数据时，返回类型仅能被确认为 `Object`，导致具体类型信息丢失。
**原理解析**：如果引用 `List<? super Apple>` 指向的底层具体类型是 `ArrayList<Object>`，容器内可能包含 `String` 或其他非相关对象。编译器无法确定读取到的元素是否为 `Apple` 或 `Fruit`。由于所有类都是 `Object` 的子类，唯一安全的推断是将读取结果视为 `Object`。
- **写入允许 (Write Permission)**：
编译器允许写入 `T` 及其子类型的对象。
**原理解析**：这是多态性的直接应用。无论底层容器是 `List<Apple>`、`List<Fruit>` 还是 `List<Object>`，`Apple` 对象（及其子类）都可以被安全地赋值给这些类型的引用。`T` 是所有可能的底层容器类型的公共下界，因此写入 `T` 是类型安全的。

---

## 4. 类型层级视野模型

为了直观理解编译器的类型检查行为，可以将其类比为在继承树上的“视野范围”：

### 4.1 向下视野 (? extends T)

- **视角**：立足于基类 `T` 向下观察。
- **可见性**：
  - **上界清晰**：明确知道所有元素至少是 `T`。因此**读取安全**。
  - **下界模糊**：无法区分具体的分支（如 Apple 或 Banana）。由于无法确认具体目标容器，因此**写入禁止**。

### 4.2 向上视野 (? super T)

- **视角**：立足于子类 `T` 向上观察。
- **可见性**：
  - **下界清晰**：明确知道 `T` 是底层所有可能类型的“后代”。因此**写入安全**。
  - **上界模糊**：无法确认具体的父类层级（可能是 Fruit，也可能是 Object）。由于无法确认读取出的对象层级，因此**读取受限**（只能退化为 Object）。

---

## 5. 总结

Java 泛型通配符的设计本质是**在类型安全的前提下，对读写权限的权衡**。编译器总是假设运行时可能出现的最坏情况（类型不匹配），并据此在编译期拦截潜在风险。

| 通配符            | 术语 | 角色 (PECS) | 读操作 (Read)          | 写操作 (Write)    | 类型安全逻辑                                  |
| ----------------- | ---- | ----------- | ---------------------- | ----------------- | --------------------------------------------- |
| **`? extends T`** | 协变 | 生产者      | **安全** (返回 T)      | **禁止**          | 无法确认具体子类容器，防止异构对象混入。      |
| **`? super T`**   | 逆变 | 消费者      | **受限** (返回 Object) | **安全** (传入 T) | 无法确认具体父类容器，但 T 兼容所有父类引用。 |

