[TOC]

# Java 泛型推断分析：构造器引用与类型约束

**关联代码**：`ch20_generics/Suppliers.java` `ch20_generics/BankTeller.java`

本文档基于 `Stream.collect` 风格的泛型工厂方法，剖析 Java 编译器在处理构造器引用时的推断逻辑。核心矛盾在于编译器如何根据上下文、表达式特异性以及目标类型来求解泛型参数 `C`。

**实验方法定义：**

```java
public static <T, C extends Collection<T>> C create(
    Supplier<C> factory, 
    Supplier<T> gen, 
    int n
) { 
    return Stream.generate(gen)
            .limit(n)
            .collect(factory, C::add, C::addAll);
}

class RandomList<T> extends ArrayList<T> {
    private Random rand = new Random(47);
    public T select() {
        return get(rand.nextInt(size()));
    }
}
```

## 1. 隐式引用与独立推断的死锁

```java
// 场景：使用 var 接收，且 RandomList 只有隐式（合成）默认构造函数
// 为什么推断的C是Collection<Teller>而不是预期的RandomList<Teller>
// Collection<Teller> result = Suppliers.create(RandomList::new, Teller::new, 4)
var result = Suppliers.create(RandomList::new, Teller::new, 4);
// 结果：静态类型被推断为 Collection<Teller>
```

**底层推断逻辑：**此处的 `RandomList::new` 是一个多态表达式，它本身不包含确切的类型信息，只代表“可以通过无参构造实例化`RandomList`”这一行为。当使用 `var` 接收结果时，处于独立推断上下文。编译器需要求解泛型 `C`。此时编译器手头的约束只有两条：

1. 来自方法签名的边界约束：`C extends Collection<Teller>`。
2. 来自实参的约束：`RandomList::new` 必须能匹配 `Supplier<C>`。

在 `RandomList` 没有显式定义默认构造函数时，编译器对于这个合成构造函数的类型推断采取了保守策略。由于隐式构造器引用（作为多态表达式）在独立推断上下文中提供的约束不足以将 C 收窄为具体子类，编译器在求解 C 时直接使用了方法签名中声明的上界，即 `Collection<Teller>`。这也是为何运行时对象是 `RandomList`（运行时 `result.getClass()` 返回 `RandomList`），但编译时静态类型仅为 `Collection` 的根本原因。

**特异性的反转（显式构造函数）**： 如果在 `RandomList` 中手动添加 `public RandomList() {}`，推断结果会修正为 `RandomList<Teller>`。 这是因为显式定义的泛型构造函数在编译器的重载解析阶段被视为具有更明确签名的泛型方法。相比于编译器自动生成的合成构造函数，显式声明允许编译器在约束生成阶段捕获更具体的下界约束，从而在求解 `C` 时避免了仅依赖上界的回退行为。

## 2. 显式类型引用的强制约束

```java
// 场景：在构造器引用中指定泛型
// RandomList<Teller> result = Suppliers.create(RandomList<Teller>::new, Teller::new, 4)
var result = Suppliers.create(RandomList<Teller>::new, Teller::new, 4);
// 结果：静态类型为 RandomList<Teller>
```

**底层推断逻辑**： `RandomList<Teller>::new` 不再是多态表达式，而是一个**独立表达式**。它的类型不依赖上下文，在推断开始前就已经固定为 `Supplier<RandomList<Teller>>`。 此时推断方向发生了逆转：**参数直接定义了上下文**。编译器接收到的指令是明确的：“参数 factory 的类型必须是 `Supplier<RandomList<Teller>>`”。根据这一强约束，泛型 `C` 被直接锁定为 `RandomList<Teller>`。这种写法消除了多态表达式的不确定性，是打破推断歧义最直接的手段。

## 3. 显式泛型参数的向下传播

```java
// 场景：在方法调用前指定泛型
// RandomList<Teller> tellers = Suppliers.<Teller, RandomList<Teller>>create(RandomList::new, Teller::new, 4)
var tellers = Suppliers.<Teller, RandomList<Teller>>create(RandomList::new, Teller::new, 4);
// 结果：静态类型为 RandomList<Teller>
```

**底层推断逻辑：** 显式指定的泛型参数 `<Teller, RandomList<Teller>>` 在推断链条的顶端直接锁定了方法签名中的 `T` 和 `C`。这为方法的第一个参数建立了一个刚性的目标类型：`Supplier<RandomList<Teller>>`。隐式引用 `RandomList::new` 虽然是多态表达式，但在这一强约束下，编译器能够直接将其进行多态适配。编译器验证发现 `new RandomList()` 的返回值与目标类型兼容，推断随即完成。这种机制完全绕过了上下文推断的模糊性，IDE 在 `create` 方法体内出现的类型提示（如 `Supplier<Collection<Teller>> factory`）仅是工具分析层面的显示问题，不影响编译器对完整类型信息的正确捕获。

## 4. 赋值上下文的反向传播

```java
// 场景：左值类型明确
// RandomList<Teller> result = Suppliers.create(RandomList::new, Teller::new, 4)
RandomList<Teller> result = Suppliers.create(RandomList::new, Teller::new, 4);
// 结果：静态类型为 RandomList<Teller>
```

**底层推断逻辑**： 这是明确的目标类型推断。赋值语句的左侧 `RandomList<Teller>` 构成了赋值上下文。 推断过程是自上而下的：

1. 编译器获知 `create` 方法的返回值必须兼容目标类型 `RandomList<Teller>`。
2. 这个约束反向传播给泛型 `C`，将其锁定为 `RandomList<Teller>`。
3. 该约束继续传播给方法参数 `factory`，要求其类型匹配 `Supplier<RandomList<Teller>>`。
4. 最终，多态表达式 `RandomList::new` 在这个强约束下被适配为具体的 `Supplier` 类型。

**总结**：Java 泛型推断并非只有“成功”和“失败”两种状态，它是一个在约束和特异性之间寻找平衡的过程：

1. **var + 隐式引用**是推断的“无人区”，编译器倾向于保守回退到接口类型（`Collection`），除非显式构造函数提供了额外的特异性信号。
2. **显式引用（`::<T>new`）**是切断推断链的“硬编码”，优先级最高。
   - 泛型类的构造器引用：泛型参数跟在类名后面，例如 `RandomList<Teller>::new`。
   - 泛型方法的引用：泛型参数跟在 `::` 后面的，例如 `Arrays::<String>asList`。
3. **赋值上下文**和**显式泛型参数**都是为多态表达式提供“锚点”，确保隐式引用能正确适配。

理解这一机制的关键在于：**多态表达式（如 `List::new`）本身没有类型，它的类型完全取决于它被放置的上下文环境以及它自身的代码特异性。**
