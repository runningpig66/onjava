[TOC]

# 泛型方法编译机制与类型推断生命周期

在 Java 泛型程序设计中，泛型方法（Generic Method）的调用并非简单的参数传递，而是一个包含**捕获转换**、**类型推断**、**边界检查**及**适用性检查**的复杂编译期过程。理解这一完整生命周期，是解释诸如 `Unchecked Warning`（未检查警告）、`Incompatible Types`（类型不兼容）或推断死锁等编译错误的理论基础。

本文将通过解析包含协变（`extends`）、逆变（`super`）及原生类型（Raw Type）等多种场景的典型泛型方法调用，揭示编译器在不同约束条件下的推断逻辑。

## 一、 泛型方法调用的生命周期

Java 编译器在处理泛型方法调用时，严格遵循以下四个逻辑阶段。这四个阶段构成了从“源码实参”到“字节码指令”的完整映射过程。

#### 第一阶段：捕获转换（Capture Conversion）

此阶段是实参的预处理过程。**其触发条件为：实参是包含通配符的参数化类型**（如 `Holder<?>` 或 `Holder<? extends Number>`）。一旦触发，编译器会为该通配符生成一个临时的、匿名的具体类型变量，称为**捕获变量（Capture Variable，标记为 CAP#）**。这一步骤将模糊的通配符映射为具有具体上下界的类型，确保了后续推断过程面对的是确定的类型实体。若实参为原生类型（Raw Type）或非泛型类型，则跳过此阶段，实参保持原样。

#### 第二阶段：类型推断（Type Inference）

此阶段是泛型编译的核心，旨在解出方法声明中类型参数 `<T>` 的具体值。**其触发条件为：方法被声明为泛型方法（即拥有 `<T>` 声明）且未显式指定类型参数。**编译器将第一阶段处理后的实参类型代入方法签名，构建一组类型约束方程。当存在多个参数对 `T` 提出约束时，编译器执行**约束交集（Constraint Intersection）**计算：

- **协变场景（LUB）**：当实参匹配形参 `T` 或 `? extends T` 时，实参构成了 `T` 的**下界**（即 `T` 必须是实参的父类）。编译器执行**最小上界（LUB）**算法，在多个下界中沿继承树向上寻找最近的公共父类（如 `Number`）。
- **逆变场景（GLB）**：当实参匹配形参 `? super T` 时，实参构成了 `T` 的**上界**（即 `T` 必须是实参的子类）。编译器执行**最大下界（GLB）**算法，在多个上界中沿继承树向下寻找最具体的公共子类（即计算类型交集）。

值得注意的是，**原生类型在此阶段处于“失语”状态**，它不提供有效的类型约束，这往往导致推断结果仅由其他强类型参数主导。

#### 第三阶段：边界检查（Bound Checking）

此阶段是针对推断结果的合法性验证。推断出 `T` 的具体类型后，编译器必须校验该类型是否满足泛型方法声明中 `<T>` 的**显式边界**（例如 `<T extends Number>`）。如果推断出的 `T`（例如 `Object`）未能满足声明的边界，即便推断过程本身在数学上成立（如 LUB 计算成功），编译仍将在此处失败。这是防止非法类型渗透的核心防御机制。

#### 第四阶段：适用性检查（Applicability Checking）

这是编译通过前的最终验证与实例化。编译器将推断并验证过的 `T` 代入方法声明，**实例化**为一个具体的方法签名（例如 `Long wildSubtype(Holder<? extends Long>, Long)`）。随后，编译器验证原始实参是否能合法地赋值给该实例化签名的形参。此阶段具有双重意义：

1. **安全性校验**：处理显式类型参数指定错误或原生类型导致的堆污染风险（此时会触发 `Unchecked Conversion` 警告）。
2. **重载决议**：在存在方法重载时，筛选出所有适用的方法候选者，并基于“最具体类型”原则选出最终目标。

---

## 二、 案例分析

### 1. 泛型生命周期深度解析：无界通配符的推断逻辑 (`r11`)

在 Java 泛型机制中，`Object r11 = wildSubtype(unbounded, lng);` 这一行代码是展示**通配符捕获（Capture Conversion）**与**多参数类型推断（Type Inference）**协同工作的经典案例。与原生类型不同，`Holder<?>` 是一个合法的泛型类型，因此它全程参与编译器的类型推断流程。以下是对该方法调用四个编译阶段的详细剖析。

#### 前置上下文

```java
// 方法声明: 
static <T> T wildSubtype(Holder<? extends T> holder, T arg)
// 实参: unbounded (类型为 Holder<?>), lng (类型为 Long)
Object r11 = wildSubtype(unbounded, lng);
```

#### 第一阶段：捕获转换

编译器的首要任务是处理实参中的通配符。当编译器扫描到第一个实参 `unbounded` 时，识别出其类型为 `Holder<?>`。根据 Java 语言规范，`Holder<?>` 等价于 `Holder<? extends Object>`。为了在后续步骤中进行精确的类型运算，编译器必须将这个“模糊”的通配符具体化。

编译器会对该通配符执行捕获转换，生成一个临时的、匿名的类型变量，通常标记为 `CAP#1`。由于原通配符的上界是 `Object`，因此 `CAP#1` 被定义为 `Object` 的某个具体子类（即 **`CAP#1 extends Object`**）。经过这一步处理，在编译器的内部视图中，第一个实参的类型从抽象的 `Holder<?>` 转变为了具体的参数化类型 **`Holder<CAP#1>`**。这是后续所有推断逻辑的基础。

#### 第二阶段：类型推断

此阶段是泛型处理的核心，编译器需要将经过处理的实参代入方法签名 `wildSubtype(Holder<? extends T> holder, T arg)`，通过求解约束方程组来确定泛型参数 `T` 的具体类型。此时，编译器面临来自两个参数的约束：

首先，根据第一个参数，实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? extends T>`。**建立约束方程**：将捕获后的实参 `CAP#1` **代入**形参通配符 `?` 的位置。由于形参定义为 `? extends T`，这要求 `CAP#1` 必须符合“继承自 `T`”的边界条件，从而推导出针对 `T` 的下界约束：**`CAP#1 <= T`**（即 `T` 必须是 `CAP#1` 的父类）。其次，根据第二个参数，实参 `Long` 必须能够赋值给形参 `T`。这意味着 **`Long` 必须是 `T` 的子类型（Long <= T）**。

编译器必须找到一个类型 `T`，使其能够同时作为 `CAP#1` 和 `Long` 的父类。由于 `CAP#1` 的具体身份未知（仅知其为 `Object` 的子类），这就构成了一个“最小上界（Least Upper Bound）”的计算问题。为了保证类型安全，`T` 必须足够宽泛以包容未知的 `CAP#1` 和已知的 `Long`。在 Java 的类型体系中，能够同时安全地包容任意 `Object` 子类（`CAP#1`）和 `Long` 的唯一公共父类就是 **`Object`**。因此，编译器最终将 `T` 推断为 **`Object`**。

#### 第三阶段：边界检查

在推断出 `T = Object` 之后，编译器需要验证这一结果是否符合泛型方法声明中的边界约束。方法 `wildSubtype` 的声明中泛型参数定义为 `<T>`，这隐式等同于 `<T extends Object>`。

编译器将推断结果 `Object` 代入边界条件进行核对。由于 `Object` 显然符合 `extends Object` 的约束，因此边界检查顺利通过。这一步确保了推断出的类型不会违反方法设计者设定的类型范围。

#### 第四阶段：适用性检查

这是编译完成前的最后一道安检。编译器根据推断出的 `T = Object`，将泛型方法实例化为具体的签名：`Object wildSubtype(Holder<? extends Object> holder, Object arg)`。编译器随后验证原始实参是否能合法地传递给这个实例化后的方法。

对于第一个参数，传入的是捕获后的 `Holder<CAP#1>`。由于 `CAP#1` 是 `Object` 的子类，因此 `Holder<CAP#1>` 逻辑上属于 `Holder<? extends Object>` 的范畴，匹配成功。对于第二个参数，传入的是 `Long`，它可以安全地向上转型为 `Object`，匹配同样成功。

与原生类型不同，整个过程完全符合泛型类型系统的规则，不存在任何类型信息丢失或潜在的堆污染风险。因此，编译器不会发出任何警告（Unchecked Warning）。这也是为什么该调用的返回值类型变成了 `Object`——因为为了兼容那个未知的通配符 `CAP#1`，泛型参数 `T` 被迫退化到了类型层级树的顶端。

### 2. 泛型生命周期深度解析：原生类型的推断逻辑 (`r9`)

在 Java 泛型机制中，`Long r9 = wildSubtype(raw, lng);` 这一行代码揭示了**原生类型（Raw Type）**与泛型类型推断系统之间的特殊交互模式。与合法的泛型调用不同，原生类型的介入会导致编译器跳过部分标准推断步骤，并触发向后兼容模式。以下是对该方法调用四个编译阶段的详细剖析，解释了为何该调用的返回值被推断为 `Long` 而非 `Object`，以及随之而来的安全风险。

#### 前置上下文

```java
// 方法声明: static <T> T wildSubtype(Holder<? extends T> holder, T arg)
// 实参: raw (类型为 Raw Holder), lng (类型为 Long)
Long r9 = wildSubtype(raw, lng);
```

#### 第一阶段：捕获转换

编译器的首要步骤是检查实参是否包含通配符。在扫描第一个实参 `raw` 时，编译器识别出其为原生类型 `Holder`。与 `Holder<?>` 不同，原生类型不包含任何类型参数或通配符（即没有尖括号 `<...>`）。因此，**捕获转换在此阶段不会发生**。

由于没有通配符需要具体化，编译器不会生成任何形如 `CAP#` 的临时类型变量。实参在编译器的内部视图中保持其原始状态，即没有任何泛型信息的 **Raw** `Holder`。这一缺失直接导致了后续推断过程中类型约束信息的匮乏。

#### 第二阶段：类型推断

进入核心的类型推断阶段，编译器需要解开泛型参数 `T` 的方程。此时，编译器面对的是完全不对称的约束条件。对于第二个参数 `lng`，编译器建立了明确的约束：实参 `Long` 必须是 `T` 的子类型（Long <= T）。然而，对于第一个参数 `raw`，情况截然不同。

根据 Java 语言规范（JLS），当原生类型作为实参传递给泛型参数时，它**被视为不存在泛型约束**。换言之，原生类型 `Holder` 无法向类型变量 `T` 提供任何有效的上界或下界信息。编译器在构建约束方程组时，实质上忽略了第一个参数对 `T` 的限制。因此，`T` 的推断完全由第二个参数 `lng` 主导。由于没有来自第一个参数的“干扰”或“稀释”（例如不需要像 R11 那样去兼容 `Object`），编译器直接依据 `Long` 的约束，将 `T` 推断为 **`Long`**。

#### 第三阶段：边界检查

在推断出 `T = Long` 后，编译器执行边界检查。泛型方法声明中的 `<T>` 隐式具有 `Object` 上界（隐式等同于 `<T extends Object>`）。编译器验证推断结果 `Long` 是否符合 `extends Object` 的约束。由于 `Long` 显然是 `Object` 的子类，边界检查顺利通过。

这一步虽然通过，但掩盖了一个潜在的逻辑矛盾：编译器仅仅验证了 `T`（由 `lng` 决定）本身是合法的，却暂时忽略了第一个参数 `raw` 是否真的适合这个推断出的 `T`。这种矛盾被延迟到了下一个阶段处理。

#### 第四阶段：适用性检查

这是编译流程的最后一步，也是编译器进行“风险提示”的环节。根据推断结果 `T = Long`，编译器将泛型方法实例化为具体的签名：`Long wildSubtype(Holder<? extends Long> holder, Long arg)`。随后，编译器尝试将原始实参匹配到这个新的签名上。

对于第二个参数，实参 `Long` 完美匹配形参 `Long`。但对于第一个参数，编译器必须将实参 **Raw** `Holder` 赋值给形参 **`Holder<? extends Long>`**。在 Java 的类型系统中，这种从原生类型到参数化类型的转换被称为**“未检查转换（Unchecked Conversion）”**。虽然为了维持与 Java 5 之前代码的兼容性，这种赋值在语法上是合法的（Assignability 通过），但它破坏了泛型的类型安全性。编译器无法保证这个原生 `Holder` 内部实际持有的对象符合 `? extends Long` 的约束（例如它可能持有 `String`）。因此，编译器虽然允许编译通过，但强制在控制台输出 **`[unchecked] unchecked conversion`** 警告，警示开发者此处存在堆污染（Heap Pollution）的严重风险。

### 3. 泛型生命周期深度解析：多参数推断与最小上界计算 (`fusion`)

在 Java 泛型体系中，`fusion(intHolder, dblVal)` 的调用案例极具代表性。它超越了单一类型的推断逻辑，展示了编译器如何处理来自不同参数的冲突约束，并通过计算类型层级中的公共祖先来解决冲突。此外，该案例还突显了**边界检查（Bound Checking）**作为独立验证步骤的重要性。

#### 前置上下文

```java
// 1. 定义：泛型方法，且 T 有边界（必须是 Number 或其子类）
//    参数1：只能装 T 或 T 的子类的 Holder
//    参数2：必须是 T 类型的具体值
static <T extends Number> T fusion(Holder<? extends T> holder, T arg) {
    return arg;
}

// ... main 方法中 ...

// 2. 实参准备
// 实参 A：Holder<? extends Integer> (注意是 Integer)
Holder<? extends Integer> intHolder = new Holder<>();

// 实参 B：Double (注意是 Double)
Double dblVal = 3.14;

// 3. 调用时刻 —— 见证奇迹的时刻
// 我们试图把 Integer 的容器和 Double 的值融合
Number result = fusion(intHolder, dblVal);
```

#### 第一阶段：捕获转换

编译器的首要步骤是对含有通配符的实参进行具象化处理。扫描参数列表时，编译器发现第一个实参 `intHolder` 具有通配符类型 `Holder<? extends Integer>`。为了在后续推断中能够引用这一具体但未知的子类型，编译器执行捕获转换，生成一个临时的类型变量 `CAP#1`。

根据原通配符的上界定义，`CAP#1` 被严格约束为 `Integer` 的子类型（即 `CAP#1 <= Integer`）。经过此步骤，实参在编译器的内部视图中被定型为 **`Holder<CAP#1>`**。第二个参数 `Double` 不包含通配符，保持原样。此时，编译器尚未开始处理泛型方法中的类型变量 `T`，仅完成了对输入数据的预处理。

#### 第二阶段：类型推断

进入推断阶段，编译器将处理后的实参代入方法签名 `fusion(Holder<? extends T> holder, T arg)`，试图求解泛型参数 `T`。此时，两个实参对 `T` 提出了不同的、看似冲突的约束：

首先，依据第一个参数，实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? extends T>`。**建立约束方程**：将捕获后的实参 `CAP#1` **代入**形参通配符 `?` 的位置。由于形参定义为 `? extends T`，这要求 `CAP#1` 必须符合“继承自 `T`”的边界条件，从而推导出针对 `T` 的下界约束：**CAP#1 <= T**（即 `T` 必须是 `CAP#1` 的父类）。由于已知 `CAP#1` 是 `Integer` 的子类型，即 **CAP#1 <= Integer**。根据传递性，这意味着 `T` **必须能够包容** `Integer`，即 **Integer <= T**。

其次，依据第二个参数，实参 `Double` 必须能够赋值给形参 `T`。这意味着 **`Double` 必须是 `T` 的子类型（Double <= T）**。

面对 `Integer` 和 `Double` 这两个平行分支的类型，编译器无法简单地选择其中之一。为了同时满足上述两个约束，编译器启动**最小上界（Least Upper Bound, LUB）**算法。该算法遍历 Java 类继承体系，寻找 `Integer` 和 `Double` 最近的公共祖先。在标准类库中，两者的共同父类是 `Number`（以及 `Object` 和 `Comparable`）。为了满足最具体的类型约束，编译器最终将 `T` 推断为 **`Number`**。

#### 第三阶段：边界检查

类型推断得出的结论 `T = Number` 必须经过方法定义的验证。方法声明中显式指定了边界 `<T extends Number>`。编译器将推断结果 `Number` 与该边界进行比对。

由于 `Number` 本身符合 `extends Number` 的约束（类型与其自身兼容），边界检查顺利通过。这一步至关重要，假设在第二阶段推断出的 LUB 是 `Object`（例如传入 `String` 和 `Integer`），那么虽然推断阶段成功找出了公共父类 `Object`，但在本阶段会因 `Object` 不满足 `extends Number` 而导致编译报错。因此，边界检查是独立于推断之外的“二次验证”机制。

#### 第四阶段：适用性检查

在确认 `T = Number` 合法后，编译器将泛型方法实例化为最终签名：`Number fusion(Holder<? extends Number> holder, Number arg)`。随后进行参数对位检查，确认实参的合法性。

对于第一个参数，传入的是 `Holder<CAP#1>`。由于 `CAP#1` 是 `Integer` 的子类，而 `Integer` 又是 `Number` 的子类，因此 `Holder<CAP#1>` 逻辑上属于 `Holder<? extends Number>` 的范畴，匹配成功。 对于第二个参数，传入的是 `Double`，它是 `Number` 的直接子类，因此可以直接赋值给 `Number` 类型的形参。

至此，所有检查通过。编译器确认该调用安全，未产生任何未检查警告，并确定该表达式的返回类型为 `Number`。这一过程完美展示了泛型系统如何在严格的类型约束下，通过计算类型交集来实现多态兼容。

### 4. 泛型生命周期深度解析：适用性检查的防御机制与重载决议

在 Java 泛型方法的编译生命周期中，第四阶段**适用性检查（Applicability Checking）**常被误认为是一个冗余的验证步骤。在常规的类型推断场景下，由于泛型参数本就是依据实参推导而来，其实参类型与实例化后的形参类型天然匹配，使得这一检查在逻辑上近乎同义反复。然而，Java 编译器保留并严格执行这一步骤并非出于形式主义，而是为了在**显式类型参数（Explicit Type Arguments）**与**方法重载决议（Method Overload Resolution）**这两种复杂语境下，维持类型系统的完整性与确定性。

#### 显式类型参数下的防御机制

当开发者在调用泛型方法时显式指定了类型参数（例如 `Wildcards.<Integer>test("Hello")`），编译器的行为模式将发生本质变化。此时，标准的**类型推断（Type Inference）**阶段被完全跳过，编译器不再根据实参 `"Hello"` 去反向推导 ，而是无条件地接受开发者指定的 `Integer` 作为的值。

```java
// 定义：简单的泛型方法
static <T> void test(T arg) { }

// 调用 1：正常推断（熟悉的过程）
test("Hello"); 
// -> 1. 捕获：无
// -> 2. 推断：T = String
// -> 3. 边界：无
// -> 4. 适用性：test(String) 接收 "Hello"，通过！(这里确实是过场)

// 调用 2：显式指定 T（跳过推断！）
Wildcards.<Integer>test("Hello");
// -> 1. 捕获：无
// -> 2. 推断：被跳过！用户强制 T = Integer。
// -> 3. 边界：无
// -> 4. 适用性检查：
//    - 方法签名变成了：test(Integer arg)
//    - 传入实参是："Hello" (String)
//    - String 能赋值给 Integer 吗？ NO！
//    - 结果：报错！❌
```

在这种情况下，适用性检查从“过场”瞬间升级为唯一的**类型防御防线**。编译器将方法签名强制实例化为 `test(Integer arg)`，随后在适用性检查阶段验证实参 `"Hello"`（String 类型）是否能赋值给形参 `Integer`。由于 String 与 Integer 之间不存在赋值兼容性，检查必然失败并抛出编译错误。若缺失这一步骤，显式指定的错误类型将绕过所有检查直接生成字节码，导致严重的运行时错误。因此，在人工干预推断机制时，适用性检查确保了方法签名与实际参数之间的最终一致性。

#### 方法重载中的候选筛选与决议

适用性检查的另一个核心职能体现在**多态性与方法重载**的处理上。当存在多个同名方法（例如非泛型的 `fusion(Integer arg)` 与泛型的 `fusion(T arg)`）且调用参数为 `100`（Integer）时，编译器必须从众多的同名方法中筛选出合法的候选者。

```java
// 方法 A：接收 Integer
static void fusion(Integer arg) { ... }

// 方法 B：泛型方法
static <T extends Number> void fusion(T arg) { ... }

// 调用：
fusion(100);
```

在此场景下，编译器会对每一个潜在的候选方法执行适用性检查。对于非泛型方法 `fusion(Integer)`，检查直接通过；对于泛型方法 `fusion(T)`，编译器先推断出 ，经边界检查后实例化为 `fusion(Integer)`，检查同样通过。此时，适用性检查的作用并非直接锁定唯一目标，而是完成了**“候选集筛选”**。随后，编译器依据 Java 语言规范中的**“最具体类型（Most Specific）”**规则在通过检查的候选者中进行仲裁。由于显式定义的 `Integer` 比通过类型擦除和推断得到的泛型 `T` 更具特异性，编译器最终选择非泛型版本。这一过程表明，适用性检查是重载决议算法得以正确运行的先决条件，它保证了进入决议流程的方法皆为类型安全的有效候选者。

综上所述，适用性检查绝非编译流程中的冗余附庸。尽管在单一泛型方法的自动推断流程中它表现为一种逻辑上的必然确认，但在显式类型指定场景中，它是防止类型错误的**最终守门人**；在复杂的方法重载场景中，它是构建合法候选集、支持精确分派的**基石**。这一机制体现了 Java 编译器设计中的防御性思维：即便前置逻辑（如推断）通常可靠，仍需在生成最终符号引用前进行一次独立、完整的兼容性验证。

### 5. 泛型生命周期深度解析：逆变场景下的双向约束与精确匹配 (`qualified`)

在 Java 泛型机制中，`wildSupertype(qualified, lng)` 示例是理解 `super` 通配符推断逻辑的基础。不同于原生类型的“约束缺失”或协变场景（extends）的“最小上界计算”，本案例展示了泛型参数 `T` 如何在来自两个方向的强约束下被精确锁定。这是泛型推断中最理想的“双向夹击”模型，也是类型安全的标准范式。

#### 前置上下文

```java
// 方法声明: 
static <T> void wildSupertype(Holder<? super T> holder, T arg)
// 实参准备:
// qualified: 类型为 Holder<Long> (精确的具体类型)
// lng:       类型为 Long
wildSupertype(qualified, lng);
```

#### 第一阶段：捕获转换

编译器的首要步骤是检查实参是否包含通配符。在扫描第一个实参 `qualified` 时，编译器识别出其类型为 `Holder<Long>`。这是一个完全确定的参数化类型，**不包含通配符**。因此，**捕获转换在此阶段被跳过**。编译器不需要生成任何形如 `CAP#` 的临时类型变量，实参直接以 `Holder<Long>` 的原始形态进入后续的推断流程。与 `Holder<?>` 相比，这意味着传入推断引擎的是一个封闭且具体的类型约束，而非开放的类型边界。

#### 第二阶段：类型推断

进入核心推断阶段，编译器将实参代入方法签名 `wildSupertype(Holder<? super T> holder, T arg)`，构建约束方程组求解 `T`。此时，`T` 同时受到了来自两个维度的严格限制：

首先，依据第二个参数 `(lng)` ，实参 `Long` 必须能够赋值给形参 `T`。这意味着 `Long` 必须是 `T` 的子类型**（Long <= T）**。这构成了 `T` 的**下界（Lower Bound）**，即 `T` 的范围不能窄于 `Long`。

其次，依据第一个参数 `(qualified)` ，实参 `Holder<Long>` 必须能够赋值给形参 `Holder<? super T>`。**建立约束方程**：将实参的具体类型 `Long` 代入形参通配符 `?` 的位置。由于形参定义为 `? super T`，这要求 `Long` 必须符合“是 `T` 的超类”这一边界条件，从而推导出针对 `T` 的上界约束：`T` 必须是 `Long` 的子类型**（T <= Long）**。

编译器将上述两个对立的约束合并：

1. **下界约束：Long <= T**
2. **上界约束：T <= Long**

在 Java 类型系统中，唯一同时满足既是 `Long` 的父类又是 `Long` 的子类的类型，仅有 `Long` 本身（根据子类型的自反性）。因此，在双向约束的逻辑交汇下，编译器将 `T` 唯一锁定为 **`Long`**。

#### 第三阶段：边界检查

推断出的 `T = Long` 需经过泛型方法声明中隐式边界 `<T extends Object>` 的验证。由于 `Long` 是 `Object` 的子类，边界检查顺利通过。

#### 第四阶段：适用性检查

编译器根据推断结果 `T = Long`，将泛型方法实例化为最终签名：`void wildSupertype(Holder<? super Long> holder, Long arg)`。随后验证实参的合法性。

对于第一个参数，传入的是 `Holder<Long>`。在泛型规则中，`super` 关系包含自身（即 `Long` 是 `Long` 的超类），因此 `Holder<Long>` 是 `Holder<? super Long>` 的合法子类型，匹配成功。对于第二个参数，传入的 `Long` 显然匹配形参 `Long`。

整个过程逻辑闭环，既没有原生类型的约束丢失，也没有通配符捕获带来的不确定性。编译器无需进行任何妥协，因此该调用能够完美编译且**不产生任何未检查警告**。

### 6. 泛型生命周期深度解析：逆变推断中的逻辑倒置与边界冲突 (`bounded`)

在 Java 泛型中，`wildSupertype(bounded, lng)` 是一个很有意义的**失败案例**。它直观地展示了将一个“生产者（Producer，`? extends`）”强行传递给一个“消费者（Consumer，`? super`）”时，编译器如何在类型推断阶段陷入逻辑悖论。不同于 `unbounded` 案例中因类型未知导致的失败，本案例的失败源于严密的**逻辑倒置**——推断出的“下界无法被上界包容”（即下界类型不是上界类型的子类型），导致类型区间坍缩。

#### 前置上下文

```java
// 方法声明: 
static <T> void wildSupertype(Holder<? super T> holder, T arg)

// 实参准备:
// bounded: 类型为 Holder<? extends Long> (明确限定了 Long 为上限)
// lng:     类型为 Long
wildSupertype(bounded, lng);
```

#### 第一阶段：捕获转换

编译器首先处理实参中的通配符。对于第一个参数 `bounded`，其类型为 `Holder<? extends Long>`。为了进行后续计算，编译器对通配符执行捕获转换，生成临时类型变量 **`CAP#1`**。

根据原通配符 `? extends Long` 的定义，`CAP#1` 被严格约束为 **`Long` 的子类型**（即 `CAP#1 <= Long`）。注意，这里的 `CAP#1` 可能恰好是 `Long`，也可能是 `Long` 的某个具体的、未知的子类（如匿名子类）。在编译器的内部视图中，实参类型确定为 **`Holder<CAP#1>`**。

#### 第二阶段：类型推断

进入核心推断阶段，编译器将实参代入方法签名 `wildSupertype(Holder<? super T> holder, T arg)`，构建约束方程组求解 `T`。此时，`T` 再次受到双向约束，但这次的方向却构成了边界冲突：

首先，依据第二个参数，实参 `Long` 必须能够赋值给形参 `T`。这意味着 **`Long` 必须是 `T` 的子类型（Long <= T）**。这确立了 `T` 的**下界（Lower Bound）**。

其次，依据第一个参数，实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? super T>`。**建立约束方程**：将捕获后的实参 `CAP#1` **代入**形参通配符 `?` 的位置。由于形参定义为 `? super T`，这要求 `CAP#1` 必须符合“是 `T` 的超类”这一边界条件，从而推导出针对 `T` 的上界约束：**`T` 必须是 `CAP#1` 的子类型（T <= CAP#1）**。

此时，编译器面临一个无解的逻辑链条：

1. **下界要求：Long <= T**
2. **上界要求：T <= CAP#1**
3. **合并推导**：这意味着必须满足 **Long <= T <= CAP#1**（即 `Long` 必须是 `CAP#1` 的子类型）。

然而，回到第一阶段的定义，**`CAP#1` 是 `Long` 的子类型（CAP#1 <= Long）**。

这就构成了**逻辑倒置**：推断要求 `CAP#1` 是 `Long` 的父类，而定义要求 `CAP#1` 是 `Long` 的子类。除非 `CAP#1` 恰好等于 `Long`，否则这两个条件无法同时满足。但由于 `CAP#1` 代表的是 `? extends Long` 中的任意未知子类，编译器无法保证它就是 `Long`。编译器无法证明 **CAP#1 (上界) 是  Long (下界) 的父类型**，推断链条彻底断裂。

#### 结论：推断失败

由于推断出的**下界（Long）无法被上界（CAP#1）安全包容**（即无法满足 Long <= CAP#1 这一必要前提），编译器判定这两个约束条件**逻辑互斥**，最终抛出 **"incompatible bounds"（不兼容的边界）** 错误。

```java
required: Holder<? super T>,T
found:    Holder<CAP#1>,long
reason: inference variable T has incompatible bounds
upper bounds: CAP#1,Object
lower bounds: Long
where T is a type-variable:
T extends Object declared in method <T>wildSupertype(Holder<? super T>,T)
where CAP#1 is a fresh type-variable:
CAP#1 extends Long from capture of ? extends Long
1 error
```

该错误日志精确地印证了上述推导：编译器发现 `T` 的下界（`Long`）高于其上界（`CAP#1`），这两个区间在逻辑上无法重合。这种失败正是 **PECS**（Producer-Extends, Consumer-Super）原则的典型体现：`? extends` 是生产者，适合读；`? super` 是消费者，适合写。这里强行把生产者当成消费者，自然会出问题。

---

## 三、 总结

### 1. 捕获优先原则（Priority of Capture Conversion）

泛型方法的调用并非直接针对通配符进行，**捕获转换**必须作为推断的前置步骤优先执行。实参中的通配符（如 `?` 或 `? extends Number`）首先被编译器映射为具体的、具有明确边界的**捕获变量（CAP#）**。这一机制确保了后续的类型推断是基于确定的类型实体（Concrete Type Entity）进行的，而非模糊的通配符。捕获变量随后作为具有严格上界或下界的已知条件，参与到泛型参数 `T` 的约束计算中。

### 2. 推断即约束交集（Inference as Constraint Intersection）

类型推断的本质是求解所有参数对泛型变量 `T` 所施加约束的**逻辑交集**。编译器根据形参的声明形式（协变或逆变），确定实参构成的边界方向及相应的计算算法：

- **下界约束与最小上界（LUB）**：当实参匹配形参 `T` 或 `? extends T` 时（即**协变**场景），实参类型构成了 `T` 的**下界（Lower Bound, Arg <= T）**。若存在多个此类实参，编译器将执行**最小上界（Least Upper Bound）**算法，在类型继承树中向上查找所有实参最近的公共父类（如 `Number`），以确保 `T` 能够兼容所有输入实参。
- **上界约束与最大下界（GLB）**：当实参匹配形参 `? super T` 时（即**逆变**场景），实参类型构成了 `T` 的**上界（Upper Bound, T <= Arg）**。若存在多个此类约束，编译器将执行**最大下界（Greatest Lower Bound）**算法，即计算所有上界类型的交集，在类型继承树中向下锁定层级最深、最具体的公共子类型（如 `Integer`）。需注意，若推断出的下界无法被上界包容（即下界不是上界的子类型），推断将因边界冲突而失败。

### 3. 原生类型的约束缺失（Constraint Absence in Raw Types）

原生类型（Raw Type）在泛型推断体系中表现为“约束失效”。当原生类型作为实参传入时，它无法向泛型参数 `T` 提供任何有效的上界或下界信息。这种**约束缺失**会导致推断逻辑失去平衡，使得 `T` 往往仅由其他非原生实参的约束主导，从而被推断为比预期更具体的类型（例如推断为 `Long` 而非 `Object`）。这种推断虽然在编译期合法，但极易在后续操作中引发堆污染（Heap Pollution），因此编译器会强制触发未检查警告。

### 4. 适用性检查的防御机制（Defensive Mechanism of Applicability Checking）

适用性检查是泛型方法编译通过前的**最终验证阶段**。即便推断过程在数学逻辑上成立，编译器仍需将推断出的具体类型代入方法签名进行实例化，并验证原始实参是否能合法赋值给新的形式参数。这一机制不仅负责拦截显式类型参数（Explicit Type Arguments）错误，更是多态环境下**重载决议（Overload Resolution）**的核心基石，确保了最终被调用的方法在类型层面上是绝对安全的。
