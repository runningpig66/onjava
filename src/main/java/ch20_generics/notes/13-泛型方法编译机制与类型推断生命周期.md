[TOC]

# 泛型方法编译机制与类型推断生命周期

**关联代码**：`ch20_generics/Wildcards.java`

在 Java 泛型程序设计中，泛型方法（Generic Method）的调用并非简单的参数传递，而是一个包含**捕获转换**、**类型推断**、**边界检查**及**适用性检查**的复杂编译期过程。理解这一完整生命周期，是解释诸如 `Unchecked Warning`（未检查警告）、`Incompatible Types`（类型不兼容）或推断死锁等编译错误的理论基础。

本文将通过解析包含协变（`extends`）、逆变（`super`）及原生类型（Raw Type）等多种场景的典型泛型方法调用，揭示编译器在不同约束条件下的推断逻辑。

## 一、 泛型方法调用的生命周期

Java 编译器在处理泛型方法调用时，严格遵循以下四个逻辑阶段。这四个阶段构成了从“源码实参”到“字节码指令”的完整映射过程。

#### 第一阶段：捕获转换（Capture Conversion）

此阶段是实参的预处理过程。**其触发条件为：实参是包含通配符的参数化类型**（如 `Holder<?>` 或 `Holder<? extends Number>`）。一旦触发，编译器会为该通配符生成一个临时的、匿名的具体类型变量，称为**捕获变量（Capture Variable，标记为 CAP#）**。这一步骤将模糊的通配符映射为具有具体上下界的类型，确保了后续推断过程面对的是确定的类型实体。若实参为原生类型（Raw Type）或非泛型类型，则跳过此阶段，实参保持原样。

#### 第二阶段：类型推断（Type Inference）

此阶段是泛型编译的核心，旨在解出方法声明中类型参数 `<T>` 的具体值。**其触发条件为：方法被声明为泛型方法（即拥有 `<T>` 声明）且未显式指定类型参数。**编译器将第一阶段处理后的实参类型代入方法签名，构建一组类型约束方程。当存在多个参数对 `T` 提出约束时，编译器执行**约束交集（Constraint Intersection）**计算：

- **协变场景（LUB）**：当实参匹配形参 `T` 或 `? extends T` 时，实参构成了 `T` 的**下界**（即 `T` 必须是实参的父类）。编译器执行**最小上界（LUB）**算法，在多个下界中沿继承树向上寻找最近的公共父类（如 `Number`）。
- **逆变场景（GLB）**：当实参匹配形参 `? super T` 时，实参构成了 `T` 的**上界**（即 `T` 必须是实参的子类）。编译器执行**最大下界（GLB）**算法，在多个上界中沿继承树向下寻找最具体的公共子类（即计算类型交集）。

值得注意的是，**原生类型在此阶段处于“失语”状态**，它不提供有效的类型约束，这往往导致推断结果仅由其他强类型参数主导。

#### 第三阶段：边界检查（Bound Checking）

此阶段是针对推断结果的合法性验证。推断出 `T` 的具体类型后，编译器必须校验该类型是否满足泛型方法声明中 `<T>` 的**显式边界**（例如 `<T extends Number>`）。如果推断出的 `T`（例如 `Object`）未能满足声明的边界，即便推断过程本身在数学上成立（如 LUB 计算成功），编译仍将在此处失败。这是防止非法类型渗透的核心防御机制。

#### 第四阶段：适用性检查（Applicability Checking）

这是编译通过前的最终验证与实例化。编译器将推断并验证过的 `T` 代入方法声明，**实例化**为一个具体的方法签名（例如 `Long wildSubtype(Holder<? extends Long>, Long)`）。随后，编译器验证原始实参是否能合法地赋值给该实例化签名的形参。此阶段具有双重意义：

1. **安全性校验**：处理显式类型参数指定错误或原生类型导致的堆污染风险（此时会触发 `Unchecked Conversion` 警告）。
2. **重载决议**：在存在方法重载时，筛选出所有适用的方法候选者，并基于“最具体类型”原则选出最终目标。

---

## 二、 案例分析

### 1. 泛型生命周期深度解析：无界通配符的推断逻辑 (`wildSubtype(unbounded, lng)`)

在 Java 泛型机制中，`Object r11 = wildSubtype(unbounded, lng);` 这一行代码是展示**通配符捕获（Capture Conversion）**与**多参数类型推断（Type Inference）**协同工作的经典案例。与原生类型不同，`Holder<?>` 是一个合法的泛型类型，因此它全程参与编译器的类型推断流程。以下是对该方法调用四个编译阶段的详细剖析。

#### 前置上下文

```java
// 方法声明: 
static <T> T wildSubtype(Holder<? extends T> holder, T arg)
// 实参: unbounded (类型为 Holder<?>), lng (类型为 Long)
Object r11 = wildSubtype(unbounded, lng);
```

#### 第一阶段：捕获转换

编译器的首要任务是处理实参中的通配符。当编译器扫描到第一个实参 `unbounded` 时，识别出其类型为 `Holder<?>`。根据 Java 语言规范，`Holder<?>` 等价于 `Holder<? extends Object>`。为了在后续步骤中进行精确的类型运算，编译器必须将这个“模糊”的通配符具体化。

编译器会对该通配符执行捕获转换，生成一个临时的、匿名的类型变量，通常标记为 `CAP#1`。由于原通配符的上界是 `Object`，因此 `CAP#1` 被定义为 `Object` 的某个具体子类（即 **`CAP#1 extends Object`**）。经过这一步处理，在编译器的内部视图中，第一个实参的类型从抽象的 `Holder<?>` 转变为了具体的参数化类型 **`Holder<CAP#1>`**。这是后续所有推断逻辑的基础。

#### 第二阶段：类型推断

此阶段是泛型处理的核心，编译器需要将经过处理的实参代入方法签名 `wildSubtype(Holder<? extends T> holder, T arg)`，通过求解约束方程组来确定泛型参数 `T` 的具体类型。此时，编译器面临来自两个参数的约束：

首先，根据第一个参数，实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? extends T>`。**建立约束方程**：将捕获后的实参 `CAP#1` **代入**形参通配符 `?` 的位置。由于形参定义为 `? extends T`，这要求 `CAP#1` 必须符合“继承自 `T`”的边界条件，从而推导出针对 `T` 的下界约束：**`CAP#1 <= T`**（即 `T` 必须是 `CAP#1` 的父类）。其次，根据第二个参数，实参 `Long` 必须能够赋值给形参 `T`。这意味着 **`Long` 必须是 `T` 的子类型（Long <= T）**。

编译器必须找到一个类型 `T`，使其能够同时作为 `CAP#1` 和 `Long` 的父类。由于 `CAP#1` 的具体身份未知（仅知其为 `Object` 的子类），这就构成了一个“最小上界（Least Upper Bound）”的计算问题。为了保证类型安全，`T` 必须足够宽泛以包容未知的 `CAP#1` 和已知的 `Long`。在 Java 的类型体系中，能够同时安全地包容任意 `Object` 子类（`CAP#1`）和 `Long` 的唯一公共父类就是 **`Object`**。因此，编译器最终将 `T` 推断为 **`Object`**。

#### 第三阶段：边界检查

在推断出 `T = Object` 之后，编译器需要验证这一结果是否符合泛型方法声明中的边界约束。方法 `wildSubtype` 的声明中泛型参数定义为 `<T>`，这隐式等同于 `<T extends Object>`。

编译器将推断结果 `Object` 代入边界条件进行核对。由于 `Object` 显然符合 `extends Object` 的约束，因此边界检查顺利通过。这一步确保了推断出的类型不会违反方法设计者设定的类型范围。

#### 第四阶段：适用性检查

这是编译完成前的最后一道安检。编译器根据推断出的 `T = Object`，将泛型方法实例化为具体的签名：`Object wildSubtype(Holder<? extends Object> holder, Object arg)`。编译器随后验证原始实参是否能合法地传递给这个实例化后的方法。

对于第一个参数，传入的是捕获后的 `Holder<CAP#1>`。由于 `CAP#1` 是 `Object` 的子类，因此 `Holder<CAP#1>` 逻辑上属于 `Holder<? extends Object>` 的范畴，匹配成功。对于第二个参数，传入的是 `Long`，它可以安全地向上转型为 `Object`，匹配同样成功。

与原生类型不同，整个过程完全符合泛型类型系统的规则，不存在任何类型信息丢失或潜在的堆污染风险。因此，编译器不会发出任何警告（Unchecked Warning）。这也是为什么该调用的返回值类型变成了 `Object`——因为为了兼容那个未知的通配符 `CAP#1`，泛型参数 `T` 被迫退化到了类型层级树的顶端。

### 2. 泛型生命周期深度解析：原生类型的推断逻辑 (`wildSubtype(raw, lng)`)

在 Java 泛型机制中，`Long r9 = wildSubtype(raw, lng);` 这一行代码揭示了**原生类型（Raw Type）**与泛型类型推断系统之间的特殊交互模式。与合法的泛型调用不同，原生类型的介入会导致编译器跳过部分标准推断步骤，并触发向后兼容模式。以下是对该方法调用四个编译阶段的详细剖析，解释了为何该调用的返回值被推断为 `Long` 而非 `Object`，以及随之而来的安全风险。

#### 前置上下文

```java
// 方法声明: static <T> T wildSubtype(Holder<? extends T> holder, T arg)
// 实参: raw (类型为 Raw Holder), lng (类型为 Long)
Long r9 = wildSubtype(raw, lng);
```

#### 第一阶段：捕获转换

编译器的首要步骤是检查实参是否包含通配符。在扫描第一个实参 `raw` 时，编译器识别出其为原生类型 `Holder`。与 `Holder<?>` 不同，原生类型不包含任何类型参数或通配符（即没有尖括号 `<...>`）。因此，**捕获转换在此阶段不会发生**。

由于没有通配符需要具体化，编译器不会生成任何形如 `CAP#` 的临时类型变量。实参在编译器的内部视图中保持其原始状态，即没有任何泛型信息的 **Raw** `Holder`。这一缺失直接导致了后续推断过程中类型约束信息的匮乏。

#### 第二阶段：类型推断

进入核心的类型推断阶段，编译器需要解开泛型参数 `T` 的方程。此时，编译器面对的是完全不对称的约束条件。对于第二个参数 `lng`，编译器建立了明确的约束：实参 `Long` 必须是 `T` 的子类型（Long <= T）。然而，对于第一个参数 `raw`，情况截然不同。

根据 Java 语言规范（JLS），当原生类型作为实参传递给泛型参数时，它**被视为不存在泛型约束**。换言之，原生类型 `Holder` 无法向类型变量 `T` 提供任何有效的上界或下界信息。编译器在构建约束方程组时，实质上忽略了第一个参数对 `T` 的限制。因此，`T` 的推断完全由第二个参数 `lng` 主导。由于没有来自第一个参数的“干扰”或“稀释”（例如不需要像 R11 那样去兼容 `Object`），编译器直接依据 `Long` 的约束，将 `T` 推断为 **`Long`**。

#### 第三阶段：边界检查

在推断出 `T = Long` 后，编译器执行边界检查。泛型方法声明中的 `<T>` 隐式具有 `Object` 上界（隐式等同于 `<T extends Object>`）。编译器验证推断结果 `Long` 是否符合 `extends Object` 的约束。由于 `Long` 显然是 `Object` 的子类，边界检查顺利通过。

这一步虽然通过，但掩盖了一个潜在的逻辑矛盾：编译器仅仅验证了 `T`（由 `lng` 决定）本身是合法的，却暂时忽略了第一个参数 `raw` 是否真的适合这个推断出的 `T`。这种矛盾被延迟到了下一个阶段处理。

#### 第四阶段：适用性检查

这是编译流程的最后一步，也是编译器进行“风险提示”的环节。根据推断结果 `T = Long`，编译器将泛型方法实例化为具体的签名：`Long wildSubtype(Holder<? extends Long> holder, Long arg)`。随后，编译器尝试将原始实参匹配到这个新的签名上。

对于第二个参数，实参 `Long` 完美匹配形参 `Long`。但对于第一个参数，编译器必须将实参 **Raw** `Holder` 赋值给形参 **`Holder<? extends Long>`**。在 Java 的类型系统中，这种从原生类型到参数化类型的转换被称为**“未检查转换（Unchecked Conversion）”**。虽然为了维持与 Java 5 之前代码的兼容性，这种赋值在语法上是合法的（Assignability 通过），但它破坏了泛型的类型安全性。编译器无法保证这个原生 `Holder` 内部实际持有的对象符合 `? extends Long` 的约束（例如它可能持有 `String`）。因此，编译器虽然允许编译通过，但强制在控制台输出 **`[unchecked] unchecked conversion`** 警告，警示开发者此处存在堆污染（Heap Pollution）的严重风险。

### 3. 泛型生命周期深度解析：多参数推断与最小上界计算 (`fusion(intHolder, dblVal)`)

在 Java 泛型体系中，`fusion(intHolder, dblVal)` 的调用案例极具代表性。它超越了单一类型的推断逻辑，展示了编译器如何处理来自不同参数的冲突约束，并通过计算类型层级中的公共祖先来解决冲突。此外，该案例还突显了**边界检查（Bound Checking）**作为独立验证步骤的重要性。

#### 前置上下文

```java
// 1. 定义：泛型方法，且 T 有边界（必须是 Number 或其子类）
//    参数1：只能装 T 或 T 的子类的 Holder
//    参数2：必须是 T 类型的具体值
static <T extends Number> T fusion(Holder<? extends T> holder, T arg) {
    return arg;
}

// ... main 方法中 ...

// 2. 实参准备
// 实参 A：Holder<? extends Integer> (注意是 Integer)
Holder<? extends Integer> intHolder = new Holder<>();

// 实参 B：Double (注意是 Double)
Double dblVal = 3.14;

// 3. 调用时刻 —— 见证奇迹的时刻
// 我们试图把 Integer 的容器和 Double 的值融合
Number result = fusion(intHolder, dblVal);
```

#### 第一阶段：捕获转换

编译器的首要步骤是对含有通配符的实参进行具象化处理。扫描参数列表时，编译器发现第一个实参 `intHolder` 具有通配符类型 `Holder<? extends Integer>`。为了在后续推断中能够引用这一具体但未知的子类型，编译器执行捕获转换，生成一个临时的类型变量 `CAP#1`。

根据原通配符的上界定义，`CAP#1` 被严格约束为 `Integer` 的子类型（即 `CAP#1 <= Integer`）。经过此步骤，实参在编译器的内部视图中被定型为 **`Holder<CAP#1>`**。第二个参数 `Double` 不包含通配符，保持原样。此时，编译器尚未开始处理泛型方法中的类型变量 `T`，仅完成了对输入数据的预处理。

#### 第二阶段：类型推断

进入推断阶段，编译器将处理后的实参代入方法签名 `fusion(Holder<? extends T> holder, T arg)`，试图求解泛型参数 `T`。此时，两个实参对 `T` 提出了不同的、看似冲突的约束：

首先，依据第一个参数，实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? extends T>`。**建立约束方程**：将捕获后的实参 `CAP#1` **代入**形参通配符 `?` 的位置。由于形参定义为 `? extends T`，这要求 `CAP#1` 必须符合“继承自 `T`”的边界条件，从而推导出针对 `T` 的下界约束：**CAP#1 <= T**（即 `T` 必须是 `CAP#1` 的父类）。由于已知 `CAP#1` 是 `Integer` 的子类型，即 **CAP#1 <= Integer**。根据传递性，这意味着 `T` **必须能够包容** `Integer`，即 **Integer <= T**。

其次，依据第二个参数，实参 `Double` 必须能够赋值给形参 `T`。这意味着 **`Double` 必须是 `T` 的子类型（Double <= T）**。

面对 `Integer` 和 `Double` 这两个平行分支的类型，编译器无法简单地选择其中之一。为了同时满足上述两个约束，编译器启动**最小上界（Least Upper Bound, LUB）**算法。该算法遍历 Java 类继承体系，寻找 `Integer` 和 `Double` 最近的公共祖先。在标准类库中，两者的共同父类是 `Number`（以及 `Object` 和 `Comparable`）。为了满足最具体的类型约束，编译器最终将 `T` 推断为 **`Number`**。

#### 第三阶段：边界检查

类型推断得出的结论 `T = Number` 必须经过方法定义的验证。方法声明中显式指定了边界 `<T extends Number>`。编译器将推断结果 `Number` 与该边界进行比对。

由于 `Number` 本身符合 `extends Number` 的约束（类型与其自身兼容），边界检查顺利通过。这一步至关重要，假设在第二阶段推断出的 LUB 是 `Object`（例如传入 `String` 和 `Integer`），那么虽然推断阶段成功找出了公共父类 `Object`，但在本阶段会因 `Object` 不满足 `extends Number` 而导致编译报错。因此，边界检查是独立于推断之外的“二次验证”机制。

#### 第四阶段：适用性检查

在确认 `T = Number` 合法后，编译器将泛型方法实例化为最终签名：`Number fusion(Holder<? extends Number> holder, Number arg)`。随后进行参数对位检查，确认实参的合法性。

对于第一个参数，传入的是 `Holder<CAP#1>`。由于 `CAP#1` 是 `Integer` 的子类，而 `Integer` 又是 `Number` 的子类，因此 `Holder<CAP#1>` 逻辑上属于 `Holder<? extends Number>` 的范畴，匹配成功。 对于第二个参数，传入的是 `Double`，它是 `Number` 的直接子类，因此可以直接赋值给 `Number` 类型的形参。

至此，所有检查通过。编译器确认该调用安全，未产生任何未检查警告，并确定该表达式的返回类型为 `Number`。这一过程完美展示了泛型系统如何在严格的类型约束下，通过计算类型交集来实现多态兼容。

### 4. 泛型生命周期深度解析：适用性检查的防御机制与重载决议

在 Java 泛型方法的编译生命周期中，第四阶段**适用性检查（Applicability Checking）**常被误认为是一个冗余的验证步骤。在常规的类型推断场景下，由于泛型参数本就是依据实参推导而来，其实参类型与实例化后的形参类型天然匹配，使得这一检查在逻辑上近乎同义反复。然而，Java 编译器保留并严格执行这一步骤并非出于形式主义，而是为了在**显式类型参数（Explicit Type Arguments）**与**方法重载决议（Method Overload Resolution）**这两种复杂语境下，维持类型系统的完整性与确定性。

#### 显式类型参数下的防御机制

当开发者在调用泛型方法时显式指定了类型参数（例如 `Wildcards.<Integer>test("Hello")`），编译器的行为模式将发生本质变化。此时，标准的**类型推断（Type Inference）**阶段被完全跳过，编译器不再根据实参 `"Hello"` 去反向推导 ，而是无条件地接受开发者指定的 `Integer` 作为的值。

```java
// 定义：简单的泛型方法
static <T> void test(T arg) { }

// 调用 1：正常推断（熟悉的过程）
test("Hello"); 
// -> 1. 捕获：无
// -> 2. 推断：T = String
// -> 3. 边界：无
// -> 4. 适用性：test(String) 接收 "Hello"，通过！(这里确实是过场)

// 调用 2：显式指定 T（跳过推断！）
Wildcards.<Integer>test("Hello");
// -> 1. 捕获：无
// -> 2. 推断：被跳过！用户强制 T = Integer。
// -> 3. 边界：无
// -> 4. 适用性检查：
//    - 方法签名变成了：test(Integer arg)
//    - 传入实参是："Hello" (String)
//    - String 能赋值给 Integer 吗？ NO！
//    - 结果：报错！❌
```

在这种情况下，适用性检查从“过场”瞬间升级为唯一的**类型防御防线**。编译器将方法签名强制实例化为 `test(Integer arg)`，随后在适用性检查阶段验证实参 `"Hello"`（String 类型）是否能赋值给形参 `Integer`。由于 String 与 Integer 之间不存在赋值兼容性，检查必然失败并抛出编译错误。若缺失这一步骤，显式指定的错误类型将绕过所有检查直接生成字节码，导致严重的运行时错误。因此，在人工干预推断机制时，适用性检查确保了方法签名与实际参数之间的最终一致性。

#### 方法重载中的候选筛选与决议

适用性检查的另一个核心职能体现在**多态性与方法重载**的处理上。当存在多个同名方法（例如非泛型的 `fusion(Integer arg)` 与泛型的 `fusion(T arg)`）且调用参数为 `100`（Integer）时，编译器必须从众多的同名方法中筛选出合法的候选者。

```java
// 方法 A：接收 Integer
static void fusion(Integer arg) { ... }

// 方法 B：泛型方法
static <T extends Number> void fusion(T arg) { ... }

// 调用：
fusion(100);
```

在此场景下，编译器会对每一个潜在的候选方法执行适用性检查。对于非泛型方法 `fusion(Integer)`，检查直接通过；对于泛型方法 `fusion(T)`，编译器先推断出 ，经边界检查后实例化为 `fusion(Integer)`，检查同样通过。此时，适用性检查的作用并非直接锁定唯一目标，而是完成了**“候选集筛选”**。随后，编译器依据 Java 语言规范中的**“最具体类型（Most Specific）”**规则在通过检查的候选者中进行仲裁。由于显式定义的 `Integer` 比通过类型擦除和推断得到的泛型 `T` 更具特异性，编译器最终选择非泛型版本。这一过程表明，适用性检查是重载决议算法得以正确运行的先决条件，它保证了进入决议流程的方法皆为类型安全的有效候选者。

综上所述，适用性检查绝非编译流程中的冗余附庸。尽管在单一泛型方法的自动推断流程中它表现为一种逻辑上的必然确认，但在显式类型指定场景中，它是防止类型错误的**最终守门人**；在复杂的方法重载场景中，它是构建合法候选集、支持精确分派的**基石**。这一机制体现了 Java 编译器设计中的防御性思维：即便前置逻辑（如推断）通常可靠，仍需在生成最终符号引用前进行一次独立、完整的兼容性验证。

### 5. 泛型生命周期深度解析：逆变场景下的双向约束与精确匹配 (`wildSupertype(qualified, lng)`)

在 Java 泛型机制中，`wildSupertype(qualified, lng)` 示例是理解 `super` 通配符推断逻辑的基础。不同于原生类型的“约束缺失”或协变场景（extends）的“最小上界计算”，本案例展示了泛型参数 `T` 如何在来自两个方向的强约束下被精确锁定。这是泛型推断中最理想的“双向夹击”模型，也是类型安全的标准范式。

#### 前置上下文

```java
// 方法声明: 
static <T> void wildSupertype(Holder<? super T> holder, T arg)
// 实参准备:
// qualified: 类型为 Holder<Long> (精确的具体类型)
// lng:       类型为 Long
wildSupertype(qualified, lng);
```

#### 第一阶段：捕获转换

编译器的首要步骤是检查实参是否包含通配符。在扫描第一个实参 `qualified` 时，编译器识别出其类型为 `Holder<Long>`。这是一个完全确定的参数化类型，**不包含通配符**。因此，**捕获转换在此阶段被跳过**。编译器不需要生成任何形如 `CAP#` 的临时类型变量，实参直接以 `Holder<Long>` 的原始形态进入后续的推断流程。与 `Holder<?>` 相比，这意味着传入推断引擎的是一个封闭且具体的类型约束，而非开放的类型边界。

#### 第二阶段：类型推断

进入核心推断阶段，编译器将实参代入方法签名 `wildSupertype(Holder<? super T> holder, T arg)`，构建约束方程组求解 `T`。此时，`T` 同时受到了来自两个维度的严格限制：

首先，依据第二个参数 `(lng)` ，实参 `Long` 必须能够赋值给形参 `T`。这意味着 `Long` 必须是 `T` 的子类型**（Long <= T）**。这构成了 `T` 的**下界（Lower Bound）**，即 `T` 的范围不能窄于 `Long`。

其次，依据第一个参数 `(qualified)` ，实参 `Holder<Long>` 必须能够赋值给形参 `Holder<? super T>`。**建立约束方程**：将实参的具体类型 `Long` 代入形参通配符 `?` 的位置。由于形参定义为 `? super T`，这要求 `Long` 必须符合“是 `T` 的超类”这一边界条件，从而推导出针对 `T` 的上界约束：`T` 必须是 `Long` 的子类型**（T <= Long）**。

编译器将上述两个对立的约束合并：

1. **下界约束：Long <= T**
2. **上界约束：T <= Long**

在 Java 类型系统中，唯一同时满足既是 `Long` 的父类又是 `Long` 的子类的类型，仅有 `Long` 本身（根据子类型的自反性）。因此，在双向约束的逻辑交汇下，编译器将 `T` 唯一锁定为 **`Long`**。

#### 第三阶段：边界检查

推断出的 `T = Long` 需经过泛型方法声明中隐式边界 `<T extends Object>` 的验证。由于 `Long` 是 `Object` 的子类，边界检查顺利通过。

#### 第四阶段：适用性检查

编译器根据推断结果 `T = Long`，将泛型方法实例化为最终签名：`void wildSupertype(Holder<? super Long> holder, Long arg)`。随后验证实参的合法性。

对于第一个参数，传入的是 `Holder<Long>`。在泛型规则中，`super` 关系包含自身（即 `Long` 是 `Long` 的超类），因此 `Holder<Long>` 是 `Holder<? super Long>` 的合法子类型，匹配成功。对于第二个参数，传入的 `Long` 显然匹配形参 `Long`。

整个过程逻辑闭环，既没有原生类型的约束丢失，也没有通配符捕获带来的不确定性。编译器无需进行任何妥协，因此该调用能够完美编译且**不产生任何未检查警告**。

### 6. 泛型生命周期深度解析：逆变推断中的逻辑倒置与边界冲突 (`wildSupertype(bounded, lng)`)

在 Java 泛型中，`wildSupertype(bounded, lng)` 是一个很有意义的**失败案例**。它直观地展示了将一个“生产者（Producer，`? extends`）”强行传递给一个“消费者（Consumer，`? super`）”时，编译器如何在类型推断阶段陷入逻辑悖论。不同于 `unbounded` 案例中因类型未知导致的失败，本案例的失败源于严密的**逻辑倒置**——推断出的“下界无法被上界包容”（即下界类型不是上界类型的子类型），导致类型区间坍缩。

#### 前置上下文

```java
// 方法声明: 
static <T> void wildSupertype(Holder<? super T> holder, T arg)

// 实参准备:
// bounded: 类型为 Holder<? extends Long> (明确限定了 Long 为上限)
// lng:     类型为 Long
wildSupertype(bounded, lng);
```

#### 第一阶段：捕获转换

编译器首先处理实参中的通配符。对于第一个参数 `bounded`，其类型为 `Holder<? extends Long>`。为了进行后续计算，编译器对通配符执行捕获转换，生成临时类型变量 **`CAP#1`**。

根据原通配符 `? extends Long` 的定义，`CAP#1` 被严格约束为 **`Long` 的子类型**（即 `CAP#1 <= Long`）。注意，这里的 `CAP#1` 可能恰好是 `Long`，也可能是 `Long` 的某个具体的、未知的子类（如匿名子类）。在编译器的内部视图中，实参类型确定为 **`Holder<CAP#1>`**。

#### 第二阶段：类型推断

进入核心推断阶段，编译器将实参代入方法签名 `wildSupertype(Holder<? super T> holder, T arg)`，构建约束方程组求解 `T`。此时，`T` 再次受到双向约束，但这次的方向却构成了边界冲突：

首先，依据第二个参数，实参 `Long` 必须能够赋值给形参 `T`。这意味着 **`Long` 必须是 `T` 的子类型（Long <= T）**。这确立了 `T` 的**下界（Lower Bound）**。

其次，依据第一个参数，实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? super T>`。**建立约束方程**：将捕获后的实参 `CAP#1` **代入**形参通配符 `?` 的位置。由于形参定义为 `? super T`，这要求 `CAP#1` 必须符合“是 `T` 的超类”这一边界条件，从而推导出针对 `T` 的上界约束：**`T` 必须是 `CAP#1` 的子类型（T <= CAP#1）**。

此时，编译器面临一个无解的逻辑链条：

1. **下界要求：Long <= T**
2. **上界要求：T <= CAP#1**
3. **合并推导**：这意味着必须满足 **Long <= T <= CAP#1**（即 `Long` 必须是 `CAP#1` 的子类型）。

然而，回到第一阶段的定义，**`CAP#1` 是 `Long` 的子类型（CAP#1 <= Long）**。

这就构成了**逻辑倒置**：推断要求 `CAP#1` 是 `Long` 的父类，而定义要求 `CAP#1` 是 `Long` 的子类。除非 `CAP#1` 恰好等于 `Long`，否则这两个条件无法同时满足。但由于 `CAP#1` 代表的是 `? extends Long` 中的任意未知子类，编译器无法保证它就是 `Long`。编译器无法证明 **CAP#1 (上界) 是  Long (下界) 的父类型**，推断链条彻底断裂。

#### 结论：推断失败

由于推断出的**下界（Long）无法被上界（CAP#1）安全包容**（即无法满足 Long <= CAP#1 这一必要前提），编译器判定这两个约束条件**逻辑互斥**，最终抛出 **"incompatible bounds"（不兼容的边界）** 错误。

```java
required: Holder<? super T>,T
found:    Holder<CAP#1>,long
reason: inference variable T has incompatible bounds
upper bounds: CAP#1,Object
lower bounds: Long
where T is a type-variable:
T extends Object declared in method <T>wildSupertype(Holder<? super T>,T)
where CAP#1 is a fresh type-variable:
CAP#1 extends Long from capture of ? extends Long
1 error
```

该错误日志精确地印证了上述推导：编译器发现 `T` 的下界（`Long`）高于其上界（`CAP#1`），这两个区间在逻辑上无法重合。这种失败正是 **PECS**（Producer-Extends, Consumer-Super）原则的典型体现：`? extends` 是生产者，适合读；`? super` 是消费者，适合写。这里强行把生产者当成消费者，自然会出问题。

---

### 小结

#### 1. 捕获优先原则

泛型方法的调用并非直接针对通配符进行，**捕获转换**必须作为推断的前置步骤优先执行。实参中的通配符（如 `?` 或 `? extends Number`）首先被编译器映射为具体的、具有明确边界的**捕获变量（CAP#）**。这一机制确保了后续的类型推断是基于确定的类型实体（Concrete Type Entity）进行的，而非模糊的通配符。捕获变量随后作为具有严格上界或下界的已知条件，参与到泛型参数 `T` 的约束计算中。

#### 2. 推断即约束交集

类型推断的本质是求解所有参数对泛型变量 `T` 所施加约束的**逻辑交集**。编译器根据形参的声明形式（协变或逆变），确定实参构成的边界方向及相应的计算算法：

- **下界约束与最小上界（LUB）**：当实参匹配形参 `T` 或 `? extends T` 时（即**协变**场景），实参类型构成了 `T` 的**下界（Lower Bound, Arg <= T）**。若存在多个此类实参，编译器将执行**最小上界（Least Upper Bound）**算法，在类型继承树中向上查找所有实参最近的公共父类（如 `Number`），以确保 `T` 能够兼容所有输入实参。
- **上界约束与最大下界（GLB）**：当实参匹配形参 `? super T` 时（即**逆变**场景），实参类型构成了 `T` 的**上界（Upper Bound, T <= Arg）**。若存在多个此类约束，编译器将执行**最大下界（Greatest Lower Bound）**算法，即计算所有上界类型的交集，在类型继承树中向下锁定层级最深、最具体的公共子类型（如 `Integer`）。需注意，若推断出的下界无法被上界包容（即下界不是上界的子类型），推断将因边界冲突而失败。

#### 3. 原生类型的约束缺失

原生类型（Raw Type）在泛型推断体系中表现为“约束失效”。当原生类型作为实参传入时，它无法向泛型参数 `T` 提供任何有效的上界或下界信息。这种**约束缺失**会导致推断逻辑失去平衡，使得 `T` 往往仅由其他非原生实参的约束主导，从而被推断为比预期更具体的类型（例如推断为 `Long` 而非 `Object`）。这种推断虽然在编译期合法，但极易在后续操作中引发堆污染（Heap Pollution），因此编译器会强制触发未检查警告。

#### 4. 适用性检查的防御机制

适用性检查是泛型方法编译通过前的**最终验证阶段**。即便推断过程在数学逻辑上成立，编译器仍需将推断出的具体类型代入方法签名进行实例化，并验证原始实参是否能合法赋值给新的形式参数。这一机制不仅负责拦截显式类型参数（Explicit Type Arguments）错误，更是多态环境下**重载决议（Overload Resolution）**的核心基石，确保了最终被调用的方法在类型层面上是绝对安全的。

## 三、 单参数场景下的泛型推断对照实验

在前一章中，我们分析了多参数交互时的复杂推断。本章将回归基础，通过控制变量法，分别在逆变（wildSupertype）和协变（wildSubtype）两种单参数上下文中，穷举原生类型、精确类型、无界通配符、有界通配符四种实参形态的推断行为。这一组对照实验将直观地揭示编译器在不同约束下的决策边界。

### 泛型生命周期深度解析：单参数逆变与无界通配符的推断 (`wildSupertype(unbounded)`)

在 Java 泛型机制中，当我们将一个无界通配符实参（`Holder<?>`）传递给一个只接受逆变参数（`Holder<? super T>`）的方法时，编译器展示出了一种特殊的推断行为。这不仅涉及到了**捕获转换**生成匿名类型变量的过程，还揭示了**类型推断**在单一约束下的自由度，以及**适用性检查**阶段如何回显出那个看似奇怪的 `<? super ?>`。

#### 前置上下文

```java
// 方法声明: (注意这里是单参数版本)
static <T> void wildSupertype(Holder<? super T> holder)

// 实参准备:
// unbounded: 类型为 Holder<?> (等价于 Holder<? extends Object>)
Holder<?> unbounded = new Holder<>();

// 调用:
wildSupertype(unbounded);
```

#### 第一阶段：捕获转换

编译器的首要任务是处理实参中的通配符。扫描实参 `unbounded` 时，识别出其类型为 `Holder<?>`。为了在后续步骤中进行精确的类型运算，编译器必须将这个通配符具体化。

编译器对 `Holder<?>` 执行捕获转换，生成一个临时的、匿名的类型变量，标记为 **`CAP#1`**。根据 Java 语言规范，`?` 等价于 `? extends Object`，因此 `CAP#1` 被定义为 `Object` 的某个具体子类（即 **`CAP#1 extends Object`**）。经过这一步处理，在编译器的内部视图中，实参的类型从抽象的 `Holder<?>` 转变为了具体的参数化类型 **`Holder<CAP#1>`**。

* **当前实参类型**: `Holder<CAP#1>`
* **CAP#1 定义**: `CAP#1 extends Object`

#### 第二阶段：类型推断

此阶段是核心，编译器需将处理后的实参 `Holder<CAP#1>` 代入方法签名 `wildSupertype(Holder<? super T> holder)`，求解泛型参数 `T`。

此时，编译器仅面临一个约束条件：实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? super T>`。

**建立约束方程**：将捕获后的实参类型 `CAP#1` 代入形参通配符 `?` 的位置。由于形参定义为 `? super T`，这要求 `CAP#1` 必须符合“是 `T` 的超类（或自身）”这一边界条件。这推导出针对 `T` 的**上界约束**：

**`T <= CAP#1`** （即 `T` 必须是 `CAP#1` 的子类型）。

**求解过程**：编译器现在手里只有一个约束：`T` 必须是 `CAP#1` 的子类型。这是一个“开放式”的方程，存在无数个解（例如 `null` 类型也是 `CAP#1` 的子类）。但在泛型推断中，当只存在上界约束时，编译器倾向于选择**最具体、最直观的非空类型**来满足约束。既然要求 `T` 是 `CAP#1` 的子类，那么让 `T` 直接等于 `CAP#1` 显然是最完美、最直接的解（因为类型自身是自身的子类型）。

因此，编译器最终将 `T` 推断为 **`CAP#1`**。

* **推断结果**: `T = CAP#1`

#### 第三阶段：边界检查

在推断出 `T = CAP#1` 之后，编译器验证这一结果是否符合泛型方法声明中的边界。方法 `wildSupertype` 的声明中泛型参数为 `<T>`，隐式等同于 `<T extends Object>`。编译器验证：`CAP#1` 是否满足 `extends Object`？回顾第一阶段的定义，`CAP#1` 本身就是 `Object` 的子类（捕获自 `? extends Object`）。因此，边界检查顺利通过。

#### 第四阶段：适用性检查

这是解释你看到那个神奇提示 `wildSupertype(Holder<? super ?> holder)` 的关键步骤。编译器根据推断结果 `T = CAP#1`，将泛型方法实例化。实例化后的方法签名为：**`void wildSupertype(Holder<? super CAP#1> holder)`**

随后，编译器验证原始实参是否能合法传递给这个新签名：传入的是 `Holder<CAP#1>`。由于 `CAP#1` 显然满足 `? super CAP#1` 的约束，匹配成功。调用合法。

#### 核心解惑：为什么 IDE 提示 `<? super ?>`？

你在 IDE（如 IntelliJ IDEA）中看到的提示 `wildSupertype(Holder<? super ?> holder)`，其实是 IDE 试图向你展示推断结果时的一种**“可视化妥协”**。

1. **真实类型**: 编译器内部推断出的 `T` 是 `CAP#1`。所以真实签名是 `Holder<? super CAP#1>`。
2. **IDE 的困境**: `CAP#1` 是一个编译器内部的匿名变量，它没有名字，源代码里也写不出来。IDE 不能显示 `Holder<? super CAP#1>`，因为你看不懂 `CAP#1` 是哪来的。
3. **IDE 的还原**: IDE 知道 `CAP#1` 捕获自那个无界通配符 `?`。在尝试把这个内部类型“翻译”回人类可读代码时，它发现 `T` 指向了一个“代表任意未知类型的占位符”。为了表达“T 是某种未知的捕获类型”，IDE 选择将其简略显示为 `?`。
4. **结果**: 于是你看到了 `Holder<? super ?>`。这在 Java 语法上是不合法的（你不能在代码里这么写），但它传达了 IDE 的意思 —— **“这里的 T 被推断为了那个捕获自无界通配符的匿名类型”**。

#### 关于“副作用”的深度解析

之前提到的“副作用”，指的就是这种推断结果对**方法内部代码编写**的影响。

假设我们在 `wildSupertype` 方法内部尝试操作这个 `holder`：

```java
static <T> void wildSupertype(Holder<? super T> holder) {
    // 假设 T 被推断为 CAP#1
    
    // 1. 读数据 (Get)
    Object obj = holder.get(); 
    // 合法。因为 T (CAP#1) 是 Object 的子类，? super T 的上界哪怕是 Object，取出来一定是 Object。
    
    // T t = holder.get(); 
    // 非法！你无法声明类型 T 的变量来接收，因为 T 是 CAP#1，你无法在代码里写 "CAP#1 t = ..."。
    // 你只能用 Object 接收。

    // 2. 写数据 (Set)
    // holder.set(???);
    // 你能往 holder 里 set 什么？
    // 方法签名是 set(T item)。此时 T = CAP#1。
    // 你需要传一个 CAP#1 类型的对象进去。
    // 但 CAP#1 是匿名的，你根本无法在方法外部或内部创建一个 "CAP#1类型" 的对象（除了 null）。
    // 所以，你无法调用 holder.set(...)，除非传 null。
}
```

**总结副作用**：
当 `T` 被推断为捕获变量 `CAP#1` 时，该方法在实质上**失去了对 `T` 类型进行写操作的能力**。你虽然成功调用了方法，但方法内部面对的是一个“不可言说”的类型 `T`，导致无法向 `holder` 写入任何具体对象。这使得该方法在这种调用下退化为只读（且只能读出 Object）。

#### 解决方案：通过“捕获助手”实现类型复活

既然 `wildSupertype` 因参数 `T` 被锁定为匿名捕获变量 `CAP#1` 而陷入“只读悖论”，若要在该方法内部恢复对 `holder` 的写入能力（例如执行 swap 操作），必须使用 **“捕获助手（Capture Helper）”** 模式。

该模式的核心逻辑在于：虽然外部引用被通配符（`?` 或 `? super`）层层包裹，导致编译器视野受限，但内存中的对象实体必然属于某个确定的参数化类型 `Holder<V>`。我们需要通过引入一个能够直接绑定该确定的（尽管对外部是未知的）类型 `V` 的辅助方法，来绕过通配符的限制，实现类型的“起死回生”。

```java
// 原始入口：虽然 T 是匿名的 CAP#1，导致 holder 无法写入
static <T> void wildSupertype(Holder<? super T> holder) {
    // 策略：不直接操作，而是将 holder 转发给一个去除了通配符干扰的 helper
    // 编译器会再次执行捕获转换，将 Holder<? super CAP#1> 的底层类型传递给 Helper
    captureHelper(holder);
}

// 捕获助手：声明确定的泛型参数 <V>
// 此时 holder 被还原为 Holder<V>，不再是消费者或生产者，而是不变的实体
private static <V> void captureHelper(Holder<V> holder) {
    // 在这个闭环中，编译器确认：
    // 1. holder.get() 返回的是 V 类型
    // 2. holder.set() 需要的是 V 类型
    // 类型完美闭环，读写能力“复活”
    V val = holder.get();
    holder.set(val); 
}
```

**机制深度解析**：
通过调用 `captureHelper(holder)`，我们迫使编译器剥离了外层的 `? super T` 视图，直接针对 `holder` 的底层类型建立了一个新的泛型上下文 `<V>`。在这个上下文中，`V` 虽然依旧未知，但它在方法内部是**统一且确定的**。`get()` 产出的 `V` 可以直接无缝喂给 `set(V)`，从而实现了逻辑上的类型自洽与操作复活。这也是 JDK 源码中 `Collections.swap` 等方法的标准实现范式。

#### 总结

对 `wildSupertype(unbounded)` 的调用流程总结如下：

1. **捕获**：`unbounded` 变为 `Holder<CAP#1>`。
2. **推断**：因为约束方程 `T <= CAP#1` 只有单向限制，编译器直接令 `T = CAP#1`。
3. **IDE 提示**：IDE 将内部不可见的 `CAP#1` 渲染为 `?`，导致你看到 `Holder<? super ?>` 这种奇怪但直观的提示。
4. **实质影响**：推断虽然成功，但 `T` 变成了一个无法在代码中实例化的匿名类型，导致方法内部无法调用任何依赖 `T` 作为参数的方法（如 `set(T)`），这在功能上是一种极大的限制。

### 泛型生命周期深度解析：原生类型的推断与未检查警告 (`wildSupertype(raw)`)

在 Java 泛型机制中，`wildSupertype(raw)` 的调用展示了**原生类型（Raw Type）**如何绕过标准的泛型类型检查系统。与通配符实参触发的复杂捕获逻辑不同，原生类型会导致推断流程的“短路”，并最终触发**未检查转换（Unchecked Conversion）**警告，标志着类型安全防线的失守。

#### 前置上下文

```java
// 方法声明: 
static <T> void wildSupertype(Holder<? super T> holder)

// 实参准备:
// raw: 类型为 Raw Holder (没有任何泛型参数)
Holder raw = new Holder();

// 调用:
wildSupertype(raw);
```

#### 第一阶段：捕获转换

编译器的首要任务是检查实参是否包含通配符。扫描实参 `raw` 时，识别出其为原生类型 `Holder`。

与 `Holder<?>` 不同，原生类型不包含任何类型参数或通配符（即没有尖括号 `<...>`）。因此，**捕获转换在此阶段被跳过**。编译器不会生成任何形如 `CAP#` 的临时类型变量。实参在编译器的内部视图中保持其原始状态，即没有任何泛型信息的 **Raw** `Holder`。这一缺失直接导致了后续推断过程中类型约束信息的匮乏。

* **当前实参类型**: Raw `Holder`
* **捕获结果**: 无（跳过）

#### 第二阶段：类型推断

进入推断阶段，编译器需将实参代入方法签名 `wildSupertype(Holder<? super T> holder)` 求解 `T`。此时，编译器面临的是“约束真空”。

**建立约束方程**：
理论上，实参 `Holder` 必须能够赋值给形参 `Holder<? super T>`。然而，根据 Java 语言规范，当原生类型作为实参传递给泛型参数时，它**被视为不存在泛型约束**。原生类型无法像 `Holder<Long>` 或 `Holder<?>` 那样，向 `T` 提供“必须是某类型的父类”或“必须是某类型的子类”的逻辑限制。

**求解过程**：
由于实参未能提供任何针对 `T` 的有效上界或下界约束，且该方法没有其他参数来辅助推断，编译器将回退到泛型参数的默认状态。在没有显式边界（如 `<T extends Number>`）的情况下，`T` 被推断为其最顶层的基准类型——**`Object`**。

因此，编译器最终将 `T` 推断为 **`Object`**。

* **推断结果**: `T = Object`

#### 第三阶段：边界检查

在推断出 `T = Object` 之后，编译器验证这一结果是否符合泛型方法声明中的边界。方法声明中 `<T>` 隐式具有 `Object` 上界。编译器验证：`Object` 是否满足 `extends Object`？显然满足。边界检查顺利通过。

#### 第四阶段：适用性检查

编译器根据推断结果 `T = Object`，将泛型方法实例化。实例化后的方法签名为：**`void wildSupertype(Holder<? super Object> holder)`**。（注：`? super Object` 在逻辑上等价于 `Object` 自身，因此形参实际上要求的是能持有 Object 的 Holder）。

随后，编译器验证原始实参是否能合法传递给这个新签名：传入的是 **Raw** `Holder`。在 Java 类型系统中，将原生类型赋值给任何参数化类型（如 `Holder<? super Object>`）都是允许的，但这属于**“未检查转换（Unchecked Conversion）”**。虽然调用合法，但为了维持与旧版本 Java 代码的兼容性，编译器允许这种赋值，同时强制在控制台输出 **`[unchecked] unchecked conversion`** 警告。

#### 核心解惑：与 `unbounded` 的区别

对比 `wildSupertype(unbounded)` 和 `wildSupertype(raw)`：

1. **推断结果不同**：

   * `unbounded` 推断出 `T = CAP#1`（一个受限的、未知的具体类型）。
   * `raw` 推断出 `T = Object`（最宽泛的类型）。

2. **方法内部能力不同**：

   * `unbounded` 导致方法内部**不可写**（只能写 null），因为 `CAP#1` 无法实例化。这虽然限制了功能，但保证了绝对的类型安全。
   * `raw` 导致方法内部**看似可写**（因为 `T` 是 `Object`，可以写入任何对象），但这是**极其危险**的。方法内部可能会向 `holder` 写入任意对象，如果传入的 `raw` 实际上引用的是一个 `Holder<Long>`，这就会导致严重的**堆污染（Heap Pollution）**。

#### 总结

对 `wildSupertype(raw)` 的调用流程总结如下：

1. **捕获**：跳过，保持原生状态。
2. **推断**：因约束缺失，`T` 退化为 `Object`。
3. **警告**：触发未检查转换警告，提示类型安全风险。
4. **实质影响**：虽然获得了推断结果 `Object`，使得方法内部拥有了最大的操作权限（可读可写 Object），但这建立在牺牲类型安全检查的基础上。这种调用应当尽量避免，或者配合 `@SuppressWarnings("unchecked")` 谨慎使用。

### 泛型生命周期深度解析：逆变场景下的精确类型推断 (`wildSupertype(qualified)`)

在 Java 泛型机制中，`wildSupertype(qualified)` 的调用代表了**最理想的推断路径**。当实参是一个具体的确定的参数化类型（如 `Holder<Long>`）时，编译器不需要进行复杂的捕获转换，也能在推断阶段获得清晰的约束，从而推断出具体的 `T`，使得方法内部拥有完整的类型操作能力。

#### 前置上下文

```java
// 方法声明: 
static <T> void wildSupertype(Holder<? super T> holder)

// 实参准备:
// qualified: 类型为 Holder<Long> (精确的具体类型，无通配符)
Holder<Long> qualified = new Holder<Long>();

// 调用:
wildSupertype(qualified);
```

#### 第一阶段：捕获转换

编译器的首要任务是检查实参是否包含通配符。扫描实参 `qualified` 时，识别出其类型为 `Holder<Long>`。

这是一个完全确定的参数化类型，**不包含任何通配符**。因此，**捕获转换在此阶段被跳过**。编译器不需要生成任何形如 `CAP#` 的临时类型变量。实参以其原始形态 `Holder<Long>` 直接进入后续的推断流程。这一特性非常关键，意味着输入给推断引擎的是一个“实实在在”的类型，而非模糊的边界。

* **当前实参类型**: `Holder<Long>`
* **捕获结果**: 无（跳过）

#### 第二阶段：类型推断

进入核心推断阶段，编译器将实参 `Holder<Long>` 代入方法签名 `wildSupertype(Holder<? super T> holder)`，求解泛型参数 `T`。

**建立约束方程**：实参 `Holder<Long>` 必须能够赋值给形参 `Holder<? super T>`。在泛型赋值规则中，要满足这一条件，实参的具体类型 `Long` 必须被包含在形参通配符 `? super T` 的范围内。这推导出：**`Long` 必须是 `T` 的超类（或自身）**。即 `Long` 必须满足 `? super T`。换个角度理解，形参要求“一个能持有 `T` 的容器”，而实参是“一个持有 `Long` 的容器”。既然这个容器能持有 `Long`，那么 `T` 必须是 `Long` 或者 `Long` 的子类（这样 `Long` 容器才能装得下 `T`）。

> **[注1] 深度解析**：关于此处为何推导出 `T <= Long`，存在“JLS 形式化推导”与“类型安全语义”两种互补的解释视角。详情请参见：[13-补充：逆变推断的双重视角深度解析](./13-补充：逆变推断的双重视角深度解析.md)

因此，编译器推导出的约束是针对 `T` 的**上界约束**：**`T <= Long`** （即 `T` 必须是 `Long` 的子类型）。

**求解过程**：编译器手中只有一个约束：`T <= Long`。
与 `unbounded` 案例中 `T <= CAP#1` 导致 `T` 匿名化不同，这里的上界 `Long` 是一个具体的、公开的类型。
在单向约束下，编译器倾向于选择最接近边界的类型作为解。因此，编译器直接将 `T` 推断为上界本身 —— **`Long`**。

* **推断结果**: `T = Long`

#### 第三阶段：边界检查

在推断出 `T = Long` 之后，编译器验证这一结果。方法声明 `<T>` 隐式边界为 `<T extends Object>`。
`Long` 显然满足 `extends Object`。边界检查通过。

#### 第四阶段：适用性检查

编译器根据 `T = Long` 实例化方法签名：**`void wildSupertype(Holder<? super Long> holder)`**。

验证原始实参 `Holder<Long>` 是否能赋值给 `Holder<? super Long>`？根据泛型子类型规则：`Holder<V>` 是 `Holder<? super V>` 的子类型。因此，`Holder<Long>` 完美匹配 `Holder<? super Long>`。调用合法。

#### 实质影响：完美的读写能力

与 `wildSupertype(unbounded)` 导致方法内部“只读”不同，`qualified` 的传入让方法内部获得了**完整的“写”能力**。

假设方法内部逻辑如下：

```java
static <T> void wildSupertype(Holder<? super T> holder) {
    // 此时 T 被推断为 Long
    // holder 的视图是 Holder<? super Long>
    
    // 写操作：合法！
    // 编译器知道 holder 至少是一个 Long 的消费者
    // 所以我们可以安全地写入 Long 类型的数据
    // T val = ...; // 假设获取到一个 Long
    // holder.set(val); // 编译通过
}
```

**总结**：
当传入精确类型实参时：

1. **无捕获**：避开了匿名变量的干扰。
2. **推断精确**：`T` 被锁定为具体的 `Long`。
3. **功能完整**：方法内部不仅类型安全，而且保留了对泛型参数的操作能力（可以写入 `Long`）。这是泛型方法调用中最“健康”的状态。

### 泛型生命周期深度解析：逆变下的捕获传递与单向约束 (`wildSupertype(bounded)`)

在 Java 泛型中，`wildSupertype(bounded)` 的调用提供了一个绝佳的观察窗口，用于对比**单参数推断**与**多参数推断**（如笔记第 6 条中的失败案例）的本质差异。本案例展示了当实参本身是一个“有界生产者”（`? extends Long`）时，编译器如何通过捕获转换将其“传递”给逆变形参，以及在缺乏冲突约束的情况下，推断机制如何“顺水推舟”地完成类型锁定。

#### 前置上下文

```java
// 方法声明: (注意这里是单参数版本)
static <T> void wildSupertype(Holder<? super T> holder)

// 实参准备:
// bounded: 类型为 Holder<? extends Long> (有上界通配符)
Holder<? extends Long> bounded = new Holder<>();

// 调用:
wildSupertype(bounded);
```

#### 第一阶段：捕获转换

编译器的首要任务是处理实参中的通配符。扫描实参 `bounded` 时，识别出其类型为 `Holder<? extends Long>`。为了进行精确计算，编译器对其执行捕获转换。

编译器生成一个临时的、匿名的类型变量 **`CAP#1`**。根据原通配符 `? extends Long` 的定义，`CAP#1` 被严格约束为 **`Long` 的子类型**（即 **`CAP#1 extends Long`**）。在编译器的内部视图中，实参类型由抽象的 `Holder<? extends Long>` 具象化为 **`Holder<CAP#1>`**。这为后续推断提供了一个确定的（尽管是匿名的）类型实体。

* **当前实参类型**: `Holder<CAP#1>`
* **CAP#1 定义**: `CAP#1 extends Long`

#### 第二阶段：类型推断

进入核心推断阶段，编译器将实参 `Holder<CAP#1>` 代入方法签名 `wildSupertype(Holder<? super T> holder)`，求解泛型参数 `T`。

**建立约束方程**：
实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? super T>`。根据泛型子类型规则（包含原则），实参的具体类型参数 `CAP#1` 必须被包含在形参通配符 `? super T` 的范围内（即 `CAP#1` 必须是 `T` 的超类）。这推导出针对 `T` 的**上界约束**：

**`T <= CAP#1`** （即 `T` 必须是 `CAP#1` 的子类型）。

**求解过程**：此时，编译器面临的局面与双参数版本（`wildSupertype(bounded, lng)`）截然不同：

* **双参数版本**：同时存在 `Long <= T`（来自参数 `lng`）和 `T <= CAP#1`（来自参数 `bounded`）。由于 `CAP#1 <= Long`，这导致了 `Long <= T <= CAP#1 <= Long` 的逻辑死锁，要求 `CAP#1` 必须恒等于 `Long`，这无法保证，因此推断失败。
* **单参数版本（本例）**：**只有** `T <= CAP#1` 这一个约束。没有其他参数强迫 `T` 必须大于等于 `Long`。

面对单一的上界约束 `T <= CAP#1`，编译器拥有完全的自由度。它遵循“选择最具体类型”的原则，直接令 `T` 等于其上界。

因此，编译器最终将 `T` 推断为 **`CAP#1`**。

* **推断结果**: `T = CAP#1`

#### 第三阶段：边界检查

推断出 `T = CAP#1` 后，编译器验证其合法性。方法声明 `<T>` 隐式边界为 `<T extends Object>`。

检查：`CAP#1` 是否满足 `extends Object`？回顾第一阶段定义，`CAP#1 extends Long`，而 `Long extends Object`。因此，`CAP#1` 显然满足约束。边界检查通过。

#### 第四阶段：适用性检查

编译器根据 `T = CAP#1` 实例化方法签名：**`void wildSupertype(Holder<? super CAP#1> holder)`**。

验证原始实参 `Holder<CAP#1>` 是否能合法传递给这个新签名？
由于 `CAP#1` 是 `CAP#1` 的超类（自反性），`Holder<CAP#1>` 完美匹配 `Holder<? super CAP#1>`。调用合法。

#### 核心解惑：IDE 提示的 `<? super ? extends Long>` 是什么？

当你在 IDE（如 IntelliJ IDEA）中查看此调用的类型提示时，可能会看到类似 **`wildSupertype(Holder<? super ? extends Long> holder)`** 这种令人费解的显示 。这其实是 IDE 尽力还原 `T = CAP#1` 的一种表示方式：

1. **还原过程**：IDE 知道 `T` 被推断为 `CAP#1`。
2. **追根溯源**：`CAP#1` 来自哪里？来自 `? extends Long` 的捕获。
3. **拼接显示**：IDE 试图把这个来源拼接到签名里，于是把 `Holder<? super T>` 中的 `T` 替换为 `? extends Long`（代表那个捕获变量）。
4. **结果**：就变成了 `Holder<? super (? extends Long)>`。虽然这在 Java 语法中是禁止的（通配符不能嵌套），但它准确地描述了编译器内部的状态——**“T 是一个被 Long 上界约束的捕获变量”**。

#### 实质影响：被“匿名”锁死的读写能力

虽然编译器成功推断出了 `T = CAP#1`（其中 `CAP#1 extends Long`），使得方法调用合法化，但这种推断结果在方法内部产生了一个尴尬的**“有类型，无对象”**的局面。

IDE 提示的 `Holder<? super ? extends Long>` 揭示了这种困境：我们面对的是一个消费未知类型的容器。

假设我们在方法内部尝试操作：

```java
static <T> void wildSupertype(Holder<? super T> holder) {
    // 此时 T = CAP#1 (捕获自 ? extends Long)
    // holder 的视图等价于 Holder<? super CAP#1>

    // 1. 写操作 (Set) —— 依然不可写！
    // holder.set(???);
    // 方法签名要求传入 T 类型对象 (即 CAP#1)。
    // 虽然我们知道 CAP#1 是 Long 的子类，但它是一个匿名类型。
    // 我们无法在代码中 new 一个 CAP#1，也无法将 Long 强转为 CAP#1（因为 CAP#1 可能是 Long 的子类）。
    // 结果：除了 null，我们无法向 holder 写入任何东西。
    
    // T val = 100L; // 编译错误！Long 不能赋值给 CAP#1
    // holder.set(100L); // 编译错误！
    
    // 2. 读操作 (Get) —— 依然只读 Object！
    // T val = holder.get(); 
    // 虽然 T (CAP#1) 是 Long 的子类，但在 ? super T 的视图下：
    // get() 返回的数据类型是由 holder 的泛型下界决定的。
    // Holder<? super ...> 的上界永远是 Object。
    // 即使 T extends Long，容器本身可能是 Holder<Object>。
    // 结果：我们只能读出 Object。
    
    Object obj = holder.get(); // 合法，但丢失了 Long 的类型信息
}
```

**深度解析**：

这就出现了一个反直觉的现象：

* **输入端**：实参 `bounded` (`Holder<? extends Long>`) 明确限制了元素是 `Long`。
* **推断端**：`T` 也确实被推断为了 `Long` 的子类。
* **操作端**：但在 `wildSupertype` 方法内部，由于 `T` 是**匿名**的，且 `Holder` 是**逆变**（Super）的，这双重限制导致我们**既不能利用 T 的上界来读取（只能读 Object），也不能利用 T 的具体类型来写入（没有实例）**。

**结论**：
`wildSupertype(bounded)` 的推断成功更多是**类型检查层面**的胜利（它证明了类型系统的逻辑自洽），但在**实用层面**，这种单参数且实参为通配符的调用，会让方法内部退化为“无操作”状态（No-op），除非使用 helper 方法进行二次捕获。这与 `wildSupertype(qualified)` 传入精确类型后获得的完美读写能力形成了鲜明对比。

#### 对比总结：为什么加个参数就报错？

* **`wildSupertype(bounded)` [成功]**：
单向约束 `T <= CAP#1`。编译器快乐地让 `T` “缩水”成 `CAP#1`（一个比 Long 还小的未知子类）。调用成功，但方法内部因 `T` 是匿名类型而**只读**。
* **`wildSupertype(bounded, lng)` [失败]**：
双向夹击。参数 `lng` 强迫 `T >= Long`，参数 `bounded` 强迫 `T <= CAP#1`。
因为 `CAP#1` 本身是 `Long` 的子类（`CAP#1 <= Long`），这要求 `T` 必须挤在 `Long` 和 `CAP#1` 之间。除非 `CAP#1` 恰好就是 `Long`，否则这就构成了**边界倒置**（下界比上界还大），导致推断崩溃。

### 泛型生命周期深度解析：原生类型的约束失效与类型擦除 (`wildSubtype(raw)`)

在 Java 泛型中，`wildSubtype(raw)` 的调用是一个关于**原生类型（Raw Type）**破坏力的教科书式案例。当原生类型介入泛型方法调用时，它不仅会绕过正常的捕获转换，还会导致类型推断机制因缺乏约束而“摆烂”，最终导致返回值类型退化为 `Object`，并伴随着不可忽视的安全警告。

#### 前置上下文

```java
// 方法声明: (注意这里是协变版本 extends)
static <T> T wildSubtype(Holder<? extends T> holder)

// 实参准备:
// raw: 类型为 Raw Holder (无泛型参数)
Holder raw = new Holder();

// 调用:
Object object1 = wildSubtype(raw);
```

#### 第一阶段：捕获转换

编译器的首要任务是检查实参是否包含通配符。扫描实参 `raw` 时，识别出其为原生类型 `Holder`。

与 `Holder<?>` 或 `Holder<? extends Long>` 不同，原生类型不包含任何类型参数或通配符。因此，**捕获转换在此阶段被彻底跳过**。编译器不会生成任何形如 `CAP#` 的临时类型变量。实参在编译器的内部视图中保持其“裸奔”状态，即没有任何泛型信息的 **Raw** `Holder`。

这直接导致了一个后果：我们失去了一个具体的（哪怕是匿名的）类型实体来作为后续推断的锚点。

* **当前实参类型**: Raw `Holder`
* **捕获结果**: 无（跳过）

#### 第二阶段：类型推断

进入核心推断阶段，编译器将实参 `raw` 代入方法签名 `wildSubtype(Holder<? extends T> holder)`，试图求解泛型参数 `T`。

**建立约束方程**：理论上，实参 `Holder` 必须能够赋值给形参 `Holder<? extends T>`。然而，根据 JLS（Java 语言规范），当原生类型作为实参传递给泛型参数时，它被视为**不存在泛型约束**。原生类型 `Holder` 内部的元素类型被擦除为 `Object`，因此它无法告诉编译器“我包含的是什么类型的元素”。这意味着：实参 `raw` 无法向 `T` 提供任何有效的**下界约束**（即无法推导出 `Something <= T`）。

**求解过程**：编译器面临一个“空约束”的方程组：

1. 没有实参对 `T` 提出下界要求。
2. 方法声明中也没有其他参数对 `T` 提出要求。

在这种情况下，编译器只能回退到 `T` 的默认状态——即其**声明的边界（Declared Bound）**。方法声明 `<T>` 隐式等同于 `<T extends Object>`。因此，为了保证最基本的合法性，编译器将 `T` 推断为其最顶层的上界 —— **`Object`**。

* **推断结果**: `T = Object`

#### 第三阶段：边界检查

在推断出 `T = Object` 之后，编译器验证这一结果。检查：`Object` 是否满足 `<T extends Object>`？显然满足。边界检查通过。

#### 第四阶段：适用性检查

编译器根据 `T = Object` 实例化方法签名：**`Object wildSubtype(Holder<? extends Object> holder)`**。

验证原始实参 `Holder`（Raw）是否能赋值给 `Holder<? extends Object>`？在 Java 中，将原生类型赋值给泛型类型属于合法操作，但这是一种**“未检查转换（Unchecked Conversion）”**。虽然赋值成功，调用合法，但编译器必须发出警告，告知开发者此处存在类型安全隐患（虽然对于 `extends` 来说，读取 `Object` 通常是安全的，但类型系统的一致性被破坏了）。

* **编译警告**: `[unchecked] unchecked conversion`

#### 实质影响：返回值的“退化”

这个案例最直观的影响体现在**返回值**上。

由于 `T` 被推断为 `Object`，方法 `wildSubtype` 的返回类型也随之变成了 `Object`。

```java
// 假设 raw 实际上是一个 Holder<Long> (通过擦除变成了 raw)
Holder<Long> qualified = new Holder<>(100L);
Holder raw = qualified;

// 调用:
// 虽然 raw 里装的是 Long，但 wildSubtype 只能返回 Object
Object obj = wildSubtype(raw); 

// Long l = wildSubtype(raw); // 编译错误！Object 无法自动转为 Long
```

**深度解析**：这就是原生类型的“传染性”。一旦在调用链中引入了原生类型，泛型系统的精度就会瞬间坍塌。编译器无法信任原生类型里的内容，只能假设它是 `Object`。这导致原本可能是 `Long`、`String` 或任何具体类型的返回值，统统被“抹平”为 `Object`。开发者被迫在后续代码中进行显式的（且不安全的）强制类型转换。

**总结**：`wildSubtype(raw)` 的推断逻辑极其简单粗暴：

1. **无视**：原生类型不提供约束。
2. **回退**：`T` 回退到 `Object`。
3. **警告**：发出未检查警告。
4. **后果**：返回值失去具体类型信息，退化为 `Object`。

### 泛型生命周期深度解析：协变场景下的精确类型推断 (`wildSubtype(qualified)`)

在 Java 泛型机制中，`wildSubtype(qualified)` 的调用代表了协变推断（Covariant Inference）的标准范式。不同于原生类型的约束缺失或通配符的模糊边界，当传入一个确定的参数化类型（如 `Holder<Long>`）给协变形参（`Holder<? extends T>`）时，编译器能够利用精确的子类型约束，独立推断出最具体的 `T`，从而实现类型信息的完整保留与还原。

#### 前置上下文

```java
// 方法声明: static <T> T wildSubtype(Holder<? extends T> holder)
// 实参准备: qualified 类型为 Holder<Long> (精确的具体类型)
Holder<Long> qualified = new Holder<Long>();

// 调用:
Long l1 = wildSubtype(qualified);
```

#### 第一阶段：捕获转换

编译器的首要任务是检查实参是否包含通配符。扫描实参 `qualified` 时，识别出其类型为 `Holder<Long>`。

这是一个完全确定的参数化类型，**不包含任何通配符**。因此，**捕获转换在此阶段被跳过**。编译器不需要生成任何形如 `CAP#` 的临时类型变量。实参以其原始形态 `Holder<Long>` 直接进入后续的推断流程。这一特性确保了输入给推断引擎的是一个封闭且清晰的类型实体，避免了匿名类型带来的不确定性。

* **当前实参类型**: `Holder<Long>`
* **捕获结果**: 无（跳过）

#### 第二阶段：类型推断

进入核心推断阶段，编译器将实参 `Holder<Long>` 代入方法签名 `wildSubtype(Holder<? extends T> holder)`，试图求解泛型参数 `T`。

**建立约束方程**：根据泛型方法调用规则，实参类型必须是形参类型的子类型。即 `Holder<Long> <: Holder<? extends T>`。根据泛型包含原则，实参的具体类型参数 `Long` 必须被包含在形参通配符 `? extends T` 的范围内。这推导出：**`Long` 必须是 `T` 的子类型（Subtype）**。

* **约束方程**：`Long <= T`。
* **约束分类**：这构成了 `T` 的**下界（Lower Bound）**。这意味着 `T` 的取值范围必须能够包容 `Long`（例如 `Long`、`Number`、`Object` 等）。

**求解过程**：编译器面临从多个满足条件的候选类型中选择 `T` 的任务。在协变推断（Producer-Extends）模式下，泛型参数 `T` 通常作为方法的返回值类型，代表了数据的“产出”。为了保留尽可能多的类型精度，防止信息丢失，编译器遵循**“最小上界（Least Upper Bound）”**或**“最具体类型”**原则。

在仅存在单一实参且提供明确下界约束 `Long <= T` 的情况下，满足该约束的**最具体（Most Specific）**类型即为下界本身。如果推断为 `Number` 或 `Object`，虽然逻辑成立，但会无端丢失“它是 Long”这一精确信息。因此，编译器在不依赖目标类型（Target Type）的情况下，能够自发地将 `T` 唯一锁定为 **`Long`**。

* **推断结果**: `T = Long`

#### 第三阶段：边界检查

在推断出 `T = Long` 之后，编译器验证这一结果是否符合泛型方法声明中的显式边界。方法声明 `<T>` 隐式等同于 `<T extends Object>`。编译器验证：`Long` 是否满足 `extends Object`？显然满足。边界检查顺利通过。

#### 第四阶段：适用性检查

编译器根据推断结果 `T = Long`，将泛型方法实例化为具体的签名：**`Long wildSubtype(Holder<? extends Long> holder)`**。

随后验证原始实参是否能合法传递给这个新签名。对于参数 `holder`，传入的是 `Holder<Long>`。根据泛型协变规则，`Holder<Long>` 是 `Holder<? extends Long>` 的合法子类型，匹配成功。

#### 实质影响：类型信息的完美保留

该案例展示了泛型方法调用中最理想的状态——**类型还原**。与原生类型 `raw` 导致返回值退化为 `Object` 不同，`qualified` 的精确类型信息通过推断链条被完整传递给了返回值。

1. **无需强制转换**：
由于 `T` 被精确推断为 `Long`，方法直接返回 `Long` 类型。调用者无需执行任何不安全的强制类型转换（Unchecked Cast），即可直接使用具体类型接收返回值。
```java
// 编译器已知返回类型为 Long，赋值安全
Long l1 = wildSubtype(qualified); 
```

2. **类型闭环**：
输入端是精确的 `Holder<Long>`，输出端是精确的 `Long`。泛型推断机制在此过程中起到了桥梁作用，确保了数据流转过程中的类型一致性与安全性，体现了泛型系统设计的核心价值。

### 泛型生命周期深度解析：协变下的捕获传递与匿名返回 (`wildSubtype(unbounded)`)

在 Java 泛型中，`wildSubtype(unbounded)` 的调用是一个展示**类型捕获（Type Capture）与匿名类型传播**的绝佳案例。当实参为无界通配符（`Holder<?>`）时，编译器不仅在内部捕获了未知的类型，还将这个“匿名身份”直接映射给了泛型参数 `T`，导致返回值变成了一个**“无法命名但类型安全”**的幽灵类型。

#### 前置上下文

```java
// 方法声明: (协变版本，T 作为返回值)
static <T> T wildSubtype(Holder<? extends T> holder)

// 实参准备:
// unbounded: 类型为 Holder<?> (等价于 Holder<? extends Object>)
Holder<?> unbounded = new Holder<>();

// 调用:
// 虽然返回的是 Object，但其背后的机理与 raw 完全不同
Object object2 = wildSubtype(unbounded);
```

#### 第一阶段：捕获转换

编译器的首要任务是处理实参中的通配符。扫描实参 `unbounded` 时，识别出其类型为 `Holder<?>`。为了在后续步骤中进行精确的类型运算，编译器必须将这个通配符具体化。

编译器对 `Holder<?>` 执行捕获转换，生成一个临时的、匿名的类型变量，标记为 **`CAP#1`**。根据 Java 语言规范，`?` 等价于 `? extends Object`，因此 `CAP#1` 被定义为 `Object` 的某个具体子类（即 **`CAP#1 extends Object`**）。经过这一步处理，在编译器的内部视图中，实参的类型从抽象的 `Holder<?>` 转变为了具体的参数化类型 **`Holder<CAP#1>`**。

* **当前实参类型**: `Holder<CAP#1>`
* **CAP#1 定义**: `CAP#1 extends Object`

#### 第二阶段：类型推断

进入核心推断阶段，编译器将处理后的实参 `Holder<CAP#1>` 代入方法签名 `wildSubtype(Holder<? extends T> holder)`，求解泛型参数 `T`。

**建立约束方程**：实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? extends T>`。根据泛型包含规则，实参的具体类型 `CAP#1` 必须被包含在形参通配符 `? extends T` 的范围内。这推导出：**`CAP#1` 必须是 `T` 的子类型（Subtype）**。

* **约束方程**：`CAP#1 <= T`。
* **约束分类**：这构成了 `T` 的**下界（Lower Bound）**。这意味着 `T` 可以是 `CAP#1`，也可以是 `Object`。

**求解过程**：编译器面临选择：是推断 `T` 为 `Object` 还是 `CAP#1`？遵循**“最小上界（Least Upper Bound）”**或**“最具体类型”**原则，在单向约束 `CAP#1 <= T` 下，满足条件的最具体类型就是下界本身 —— **`CAP#1`**。

因此，编译器最终将 `T` 推断为 **`CAP#1`**。

* **推断结果**: `T = CAP#1`

#### 第三阶段：边界检查

在推断出 `T = CAP#1` 之后，编译器验证这一结果。方法声明 `<T>` 隐式边界为 `<T extends Object>`。检查：`CAP#1` 是否满足 `extends Object`？回顾第一阶段定义，`CAP#1` 本身就是 `Object` 的子类。因此，边界检查顺利通过。

#### 第四阶段：适用性检查

编译器根据 `T = CAP#1` 实例化方法签名：**`CAP#1 wildSubtype(Holder<? extends CAP#1> holder)`**。

验证原始实参 `Holder<CAP#1>` 是否能赋值给 `Holder<? extends CAP#1>`？根据泛型协变规则：`Holder<CAP#1>` 显然是 `Holder<? extends CAP#1>` 的子类型（自反性）。因此，调用合法。

#### 核心解惑：IDE 提示的 `static <T> ? wildSubtype(Holder<? extends ?> holder)` 是什么？

当您在 IDE（如 IntelliJ IDEA）中查看此调用的类型提示时，可能会看到类似的显示：

> `static <T> ? wildSubtype(Holder<? extends ?> holder)`

这串充满问号的签名其实是 IDE 尽力还原编译器内部状态的结果：

1. **返回值 `?`**：IDE 知道 `T` 被推断为 `CAP#1`。这是一个匿名捕获变量，没有源码层面的名字。IDE 为了表示“这是一个未知的具体类型”，将其渲染为 `?`。
  * **真实含义**：返回类型是 `CAP#1`。

2. **参数 `Holder<? extends ?>`**：这是对 `Holder<? extends CAP#1>` 的可视化简写。

  * 第一个 `?` 是方法签名自带的通配符。
  * 第二个 `?`（extends 后面的那个）代表被绑定到泛型参数 `T` 上的 `CAP#1`。
  * **真实含义**：方法接收一个 `Holder`，其元素类型上界是那个捕获到的匿名类型 `CAP#1`。

这与我们在逆变场景（`wildSupertype`）中看到的 `Holder<? super ?>` 异曲同工，都是**“匿名捕获变量”**在工具层面的视觉回显。它证明了编译器确实在这个过程中传递了一个具体的（虽然是匿名的）类型对象，而不是简单地回退到了 `Object`。

#### 实质影响：安全的“匿名”返回值与捕获的意义

这个案例最有趣的地方在于**返回值**的处理，以及对“捕获是否有意义”的探讨。

1. **返回类型是匿名的**：由于 `T` 被推断为 `CAP#1`，方法的返回类型实际上就是 `CAP#1`。这是一个编译器内部的类型，我们在 Java 源代码中无法写出它的名字。
2. **只能赋给 Object**：作为调用者，拿到一个 `CAP#1` 类型的对象后，我们能把它赋给谁？由于我们只知道 `CAP#1 extends Object`，所以我们在代码中唯一能用的父类引用就是 `Object`。
```java
Object obj = wildSubtype(unbounded); // 合法
// Long l = wildSubtype(unbounded); // 编译错误！CAP#1 不一定是 Long
```

3. **捕获在协变下的意义（与“捕获助手”对比）**：您可能会问：*“在逆变场景下，捕获助手（Capture Helper）能帮我们恢复写能力。这里是协变，反正 holder 都是只读的，捕获还有意义吗？”*
    **答案是肯定的，意义在于“类型链路的安全性”：**

  * **如果没有捕获（像 Raw Type）**：`T` 会退化为 `Object`，编译器会发出**未检查警告**。这代表编译器放弃了类型追踪，无法保证安全。
  * **有了捕获**：编译器生成了 `CAP#1` 并将其传递给 `T`。虽然我们最终只能用 `Object` 接收返回值，但这整个过程是**类型安全（Type-Safe）**的，没有警告。编译器明确知道“返回的东西”就是“容器里装的东西”，它们是同一个 `CAP#1`。

**关于读写能力**：在协变（`extends`）上下文中，`Holder<?>` 本质上就是**只读**的（只能写入 `null`）。这一点是由 `? extends` 的性质决定的，捕获转换无法改变这一物理属性。因此，在这里我们不需要（也无法通过）捕获助手来“复活”写能力，捕获的主要贡献在于实现了**零警告的类型推导闭环**。

**总结**：`wildSubtype(unbounded)` 展示了泛型系统如何优雅地处理未知类型：

1. **捕获**：将 `?` 具象化为 `CAP#1`。
2. **传递**：将 `CAP#1` 传递给泛型参数 `T`。
3. **显示**：IDE 用 `?` 来指代这个不可言说的 `CAP#1`。
4. **结果**：虽然最终都只能用 `Object` 接收，但这是**经过严密验证的安全的 Object**，而非原生类型那样的“裸奔”Object。

### 泛型生命周期深度解析：协变下的有界捕获与类型传播 (`wildSubtype(bounded)`)

在 Java 泛型中，`wildSubtype(bounded)` 的调用是理解**有界通配符（Bounded Wildcard）**参与类型推断的关键案例。与 `unbounded` 捕获到模糊的 `Object` 不同，本案例展示了编译器如何精准地捕获通配符的上界（Upper Bound），并将其完整地传递给泛型参数 `T`，从而实现**“虽然匿名，但有明确边界”**的类型返回。

#### 前置上下文

```java
// 方法声明: (协变版本，T 作为返回值)
static <T> T wildSubtype(Holder<? extends T> holder)

// 实参准备:
// bounded: 类型为 Holder<? extends Long> (明确指定了上界是 Long)
Holder<? extends Long> bounded = new Holder<>();

// 调用:
// 注意：这里可以直接用 Long 接收返回值，比 unbounded 更强大
Long l2 = wildSubtype(bounded);
```

#### 第一阶段：捕获转换

编译器的首要任务是处理实参中的通配符。扫描实参 `bounded` 时，识别出其类型为 `Holder<? extends Long>`。为了进行精确计算，编译器必须对这个有界通配符执行捕获转换。

编译器生成一个临时的、匿名的类型变量 **`CAP#1`**。与 `unbounded` 案例中 `CAP#1 extends Object` 不同，这里原通配符明确指定了上界 `Long`。因此，`CAP#1` 被严格定义为 **`Long` 的子类型**（即 **`CAP#1 extends Long`**）。在编译器的内部视图中，实参类型由 `Holder<? extends Long>` 具象化为 **`Holder<CAP#1>`**。

这一步至关重要：`CAP#1` 携带了“我是 Long 的后代”这一关键遗传信息，这决定了后续推断的质量。

* **当前实参类型**: `Holder<CAP#1>`
* **CAP#1 定义**: `CAP#1 extends Long`

#### 第二阶段：类型推断

进入核心推断阶段，编译器将处理后的实参 `Holder<CAP#1>` 代入方法签名 `wildSubtype(Holder<? extends T> holder)`，求解泛型参数 `T`。

**建立约束方程**：实参 `Holder<CAP#1>` 必须能够赋值给形参 `Holder<? extends T>`。根据泛型包含规则，实参的具体类型 `CAP#1` 必须被包含在形参通配符 `? extends T` 的范围内。这推导出：**`CAP#1` 必须是 `T` 的子类型（Subtype）**。

* **约束方程**：`CAP#1 <= T`。
* **约束分类**：这构成了 `T` 的**下界（Lower Bound）**。

**求解过程**：编译器面临选择：`T` 可以是 `CAP#1`，也可以是 `Long`，也可以是 `Number` 或 `Object`。遵循**“最具体类型”**原则，在单向约束 `CAP#1 <= T` 下，编译器选择最具体的下界本身 —— **`CAP#1`**。

因此，编译器最终将 `T` 推断为 **`CAP#1`**。

* **推断结果**: `T = CAP#1` （注意：此处的 `CAP#1` 带有 `extends Long` 的属性）

#### 第三阶段：边界检查

在推断出 `T = CAP#1` 之后，编译器验证这一结果。方法声明 `<T>` 隐式边界为 `<T extends Object>`。检查：`CAP#1` 是否满足 `extends Object`？显然满足（因为 `CAP#1 extends Long extends Object`）。边界检查通过。

#### 第四阶段：适用性检查

编译器根据 `T = CAP#1` 实例化方法签名：**`CAP#1 wildSubtype(Holder<? extends CAP#1> holder)`**。

验证原始实参 `Holder<CAP#1>` 是否能赋值给 `Holder<? extends CAP#1>`？显然成立（自反性）。调用合法。

#### 核心解惑：IDE 提示的 `? extends Long` 是什么？

当您在 IDE（如 IntelliJ IDEA）中查看此调用时，会看到那个著名的、极其复杂的提示 ：

> `static <T> ? extends Long wildSubtype(Holder<? extends ? extends Long> holder)`

这串像绕口令一样的签名，是 IDE 忠实还原编译器内部状态的产物。让我们层层剥开它的面纱：

1. **返回值 `? extends Long`**：

   * **现象**：IDE 并没有像 `unbounded` 那样只显示一个孤零零的 `?`。它加上了 `extends Long`。
   * **本质**：编译器推断出 `T = CAP#1`。IDE 查阅 `CAP#1` 的档案，发现它定义为 `CAP#1 extends Long`。
   * **解读**：IDE 在告诉你：“返回的是一个匿名的捕获类型（`?`），但我知道这个匿名类型肯定是 **Long 的子类**（`extends Long`）。”

2. **参数 `Holder<? extends ? extends Long>`**：

   * **现象**：两个 `?` 和两个 `extends` 嵌套。
   * **本质**：这是对 `Holder<? extends T>` 的视觉化。
     * 外层的 `? extends` 是方法签名自带的。
     * 内层的 `T` 被替换为了 `? extends Long`（即 `CAP#1` 的视觉表示）。
   * **解读**：方法接收一个 Holder，其内容类型的上界是“那个捕获到的、继承自 Long 的匿名类型”。

这个提示非常有价值，它证明了**泛型边界信息没有丢失**。编译器不仅捕获了类型，还保留了类型的**继承约束**。

#### 实质影响：有界返回值的实用性

这个案例与 `wildSubtype(unbounded)` 形成了鲜明对比，体现了“有界”带来的巨大优势。

1. **返回值更具体**：

   * `unbounded` 返回的 `CAP#1` 只能当 `Object` 用。
   * `bounded` 返回的 `CAP#1`，由于编译器知道它 `extends Long`，所以它**可以安全地赋值给 Long 类型的变量**。

```java
// 编译通过！
// 逻辑：T (CAP#1) 是 Long 的子类，所以返回的 CAP#1 对象必然也是 Long 的实例
Long l2 = wildSubtype(bounded); 

// 当然也可以赋给 Number 或 Object
Number n = wildSubtype(bounded);
```

2. **类型安全的“向下”传递**：通过捕获转换和类型推断，实参 `Holder<? extends Long>` 中的上界信息 `Long` 成功穿透了泛型方法，直接传递给了返回值。这意味着我们在使用通配符时，并没有完全丢失类型精度——我们保留了“上界”这一核心特征。

**总结**：`wildSubtype(bounded)` 展示了泛型推断的精细度：

1. **捕获**：将 `? extends Long` 具象化为 `CAP#1 extends Long`。
2. **传递**：将带有 `Long` 约束的 `CAP#1` 传递给 `T`。
3. **显示**：IDE 用 `? extends Long` 精准描述了这个受限的匿名类型。
4. **结果**：返回值虽然是匿名的，但因为保留了 `Long` 上界，所以可以直接作为 `Long` 使用。这是**“有界通配符”**存在的最大意义——在提供灵活性的同时，守住了类型的底线。

### 泛型生命周期深度解析：逆变实参的向上转型与写入能力擦除 (`unboundedArg(bounded1)`)

在 Java 泛型类型系统中，`unboundedArg(bounded1)` 的调用是一个展示**泛型子类型多态（Subtyping Polymorphism）与能力权衡（Capability Trade-off）的经典案例。不同于泛型方法推断中复杂的方程求解，本案例聚焦于非泛型方法调用中的向上转型**机制，揭示了当一个具有特定写入能力的逆变容器（`Holder<? super Integer>`）被赋值给无界通配符形参（`Holder<?>`）时，类型系统如何以牺牲操作能力为代价来换取兼容性。

#### 前置上下文

```java
// 方法声明: (普通方法，非泛型方法)
// 形参: holder (类型为 Holder<?>)
static void unboundedArg(Holder<?> holder) {
    // 方法内部逻辑...
}

// 实参准备:
// bounded1: 类型为 Holder<? super Integer> (逆变，具备写入 Integer 的能力)
Holder<? super Integer> bounded1 = new Holder<>();

// 调用:
unboundedArg(bounded1);
```

#### 第一阶段：捕获转换

虽然目标方法 `unboundedArg` 并非泛型方法，但编译器在处理包含通配符的实参时，依然会执行捕获转换以确定实参的具体类型身份。

扫描实参 `bounded1` 时，识别出其类型为 `Holder<? super Integer>`。编译器为通配符生成一个临时的、匿名的类型变量 **`CAP#1`**。根据 `? super Integer` 的定义，`CAP#1` 被约束为 **`Integer` 的超类**（即 **`Integer <: CAP#1`**）。在编译器的内部视图中，实参从抽象的通配符类型具象化为参数化类型 **`Holder<CAP#1>`**。这一步确保了实参在类型系统中是一个具有确定边界的实体。

* **当前实参类型**: `Holder<CAP#1>`
* **CAP#1 定义**: `Integer <: CAP#1`

#### 第二阶段：类型推断 —— **跳过**

**此阶段被跳过**。这是理解本案例的关键点。

类型推断的触发条件是方法声明中存在待求解的类型参数（如 `<T>`）。观察 `unboundedArg` 的声明：`static void unboundedArg(Holder<?> holder)`。该方法签名前**不存在** `<T>` 声明，因此它是一个**非泛型方法（Non-generic Method）**。编译器无需构建约束方程，也无需计算最小上界（LUB）或最大下界（GLB）。编译流程直接进入类型兼容性检查环节。

#### 第三阶段：边界检查 —— **跳过**

由于不存在类型参数 `T`，自然也不存在形如 `<T extends Number>` 的边界约束。此阶段同样被跳过。

#### 第四阶段：适用性检查

这是本案例的核心验证阶段。编译器必须验证经过捕获转换的实参 `Holder<CAP#1>` 是否能合法地赋值给形参 `Holder<?>`。这本质上是一个**子类型检查（Subtyping Check）**。

**判定逻辑**：根据 Java 语言规范（JLS），`Holder<?>`（等同于 `Holder<? extends Object>`）是所有 `Holder` 参数化类型的**超类型（Supertype）**。这构成了泛型系统的**顶层包含规则**：

> 对于任意类型 `S`，`Holder<S>` `<:` `Holder<?>`。

**推导过程**：

1. **实参分析**：实参的底层类型是 `CAP#1`。虽然 `CAP#1` 是一个匿名变量，但它在逻辑上必然属于 Java 类型体系中的某一类型（Type）。
2. **包含关系验证**：

   * **形参集合**：`Holder<?>` 代表“持有任意类型的 Holder”。其类型集合覆盖了 Java 宇宙中的所有引用类型。
   * **实参集合**：`Holder<? super Integer>` 代表“持有 Integer 父类的 Holder”。其类型集合包含 `Integer`, `Number`, `Object`, `Serializable` 等。
   * **结论**：实参所代表的类型集合是形参类型集合的**真子集**。

因此，**`Holder<CAP#1> <: Holder<?>`** 成立。编译器判定实参是形参的合法子类型，适用性检查通过，调用合法。

#### 实质影响：写入能力的“降维打击”

虽然调用在语法上是合法的（向上转型），但这一转型过程伴随着**操作能力的严重丢失**。这正是泛型系统中“灵活性”与“功能性”的零和博弈。

1. **调用前（Context of Caller）**：变量 `bounded1` 的类型是 `Holder<? super Integer>`。这是一个典型的**消费者（Consumer）**视图。编译器利用下界信息（Lower Bound），允许开发者向其中写入 `Integer` 类型的数据。
```java
bounded1.set(100); // 合法：编译器确认 100 是 Integer，符合 ? super Integer 的约束
```

2. **调用后（Context of Callee）**：在 `unboundedArg` 方法内部，参数 `holder` 的类型退化为 `Holder<?>`。`?` 是一个**无界通配符**，它丢失了所有的下界信息。

  * **写入禁止**：由于编译器无法确定 `?` 具体代表什么（可能是 `Integer`，也可能是 `String`），为了保证类型安全，编译器**禁止调用任何包含泛型参数作为入参的方法**（如 `set(E)`）。
  * **结果**：原本具备的“写入 Integer”能力，在传递给方法的瞬间被**擦除**了。

```java
static void unboundedArg(Holder<?> holder) {
    // holder.set(100); 
    // 编译错误！
    // 错误原因：实参 captured#1 of ? 与形参 Integer 不兼容。
    // 尽管运行时它确实是一个能装 Integer 的容器，但静态类型检查已将其视为“未知容器”。
}
```

**总结**：`unboundedArg(bounded1)` 的过程并非简单的传参，而是一次**类型视图的降级**。

1. **类型转换**：从具体的 `Holder<? super Integer>` 向上转型为通用的 `Holder<?>`。
2. **推断行为**：因方法非泛型，跳过推断，仅执行子类型检查。
3. **能力变化**：实参从**“可写的消费者”**退化为**“只读的旁观者”**（仅能读取 Object）。这种现象在 Kotlin 中被称为 **Out-Projected Type** 限制，是泛型系统防止堆污染的最后一道防线。
