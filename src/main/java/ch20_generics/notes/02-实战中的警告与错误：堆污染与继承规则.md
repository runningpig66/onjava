[TOC]

# 笔记二：实战中的警告与错误——堆污染与继承规则

**标签**：`Java` `Generics` `HeapPollution` `RawTypes` `Wildcards`
**日期**：2025-12-27
**代码案例**：`ErasureAndInheritance.java`

---

## 1. 标记 [1]：原生类型的使用 (Raw Use)

```java
// [1] Warning: Raw use of parameterized class 'GenericBase'
// 警告：对参数化类 'GenericBase' 的原生（Raw）使用
@SuppressWarnings("rawtypes")
class Derived2 extends GenericBase {
}
```

**现象**：`Derived2` 在继承 `GenericBase` 时，未指定具体的泛型参数 `<T>`。这种不带尖括号的写法，被称为**原生类型（Raw Type）**。

**编译器行为**：当使用原生类型时，泛型类的所有类型参数 `T` 在该类视域内都会被擦除为上界（通常是 `Object`）。此时，编译器将**关闭**针对该类的泛型类型检查。

> **💡 思维模型：瓶子与标签**
> 
> * **泛型类 (`GenericBase<T>`)**：是一个贴了标签的瓶子。比如 `GenericBase<String>` 贴着“只能装水”。
> * **原生类型 (`Derived2`)**：当你写 `Derived2 extends GenericBase` 时，相当于**亲手撕毁了瓶子上的标签**。它变成了一个没有任何限制的黑洞瓶子。你在定义 `Derived2` 时，相当于对编译器说：“我不关心在这个类里 `T` 到底是什么，我就要把它当成最原始的 Object 用。”（这就导致了第二个警告的出现。）
> 

**为什么是警告而非错误？**

* **迁移兼容性（Migration Compatibility）**：这是 Java 5 为了兼容之前（Pre-generics）的旧代码而保留的特性。在 Java 5 之前，所有的类都没有泛型，旧代码中大量存在不带尖括号的类使用方式。为了让旧代码能在新版 JDK 上跑通，编译器必须允许这种写法存在。
* **代价**：使用原生类型意味着放弃了编译期的类型安全保障，可能导致运行时的类型转换异常。在 `Derived2` 的世界里，`GenericBase` 内部所有的 `T` 都会被强制退化为 `Object`。编译器虽然允许你这么做，但它必须弹出一个警告提醒开发者：“**你把安全检查关掉了！你正在使用一个‘不负责任’的引用，我没法保证里面的数据类型。**”

---

## 2. 标记 [2]：未检查的调用 (Unchecked Call) 与堆污染

```java
@SuppressWarnings("unchecked")
public static void main(String[] args) {
    Derived2 d2 = new Derived2();
    Object obj = d2.get();
    // [2] Warning: Unchecked call to 'set(T)' as a member of raw type 'ch20_generics.GenericBase'
    // 警告：作为原生类型成员的 'set(T)' 方法的未检查调用
    d2.set(obj);
}
```

* **警告的本质**：编译器意在警示——“开发者正在向容器中插入未经验证的数据。由于使用了原生类型，编译器无法保证类型安全，由此产生的运行时风险由开发者承担。”

#### 核心概念：堆污染 (Heap Pollution)

* **定义**：当一个参数化类型（Parameterized Type）的变量，引用了一个实际上并不是该参数类型的对象时，即发生堆污染。
* **本质**：**静态类型（引用泛型声明）与运行时类型（实际对象类型）不一致。**
* **根源**：**类型擦除**导致泛型信息在运行时丢失，如果编译器在编译期没能拦截住类型不匹配的操作，这种不一致就会保留到运行时。

> **💡 思维模型：名实不符**
> * **标签（引用）**：声明为 `GenericBase<String>`，承诺只包含字符串。
> * **实体（堆对象）**：内存中实际存储的却是 `Integer`。
> * **后果**：当程序试图按照标签说明去使用实体时（例如把 `Integer` 当 `String` 用），程序崩溃。
> 

#### 场景分析：堆污染的发生过程

结合 `Derived2` 代码，我们可以将堆污染的形成拆解为三个阶段：

**第一步：原生类型的初始化（安全防线失效）**

```java
// Warning: Raw use of parameterized class 'GenericBase'
// 虽然 Derived2 定义时继承自 GenericBase<T>，但此处使用了原生类型。
// 泛型边界检查在此处被关闭。
class Derived2 extends GenericBase {}
...
Derived2 d2 = new Derived2(); 
```

**第二步：未检查的插入（污染发生）**

```java
// Warning: Unchecked call to 'set(T)' as a member of raw type 'GenericBase'
// 由于 d2 是原生类型，set(T) 方法的签名在编译器眼中退化为 set(Object)。
// 编译器允许插入 Integer，尽管这可能违背了设计初衷。
Object obj = 123;
d2.set(obj); 
```

* **状态分析**：此时此刻，堆污染已经发生。内存中的 `GenericBase` 对象处于“脏”状态：原本设计用来存储 `T` 的空间，现在持有一个未知的 `Object` (Integer)。

**第三步：运行时的延迟崩溃（代价兑现）**

这是堆污染最危险的地方：错误往往不会在插入时立即爆发，而是在后续读取时才显现。

```java
// 假设将脏对象赋值给一个带泛型的引用（为了兼容性，编译器允许此操作）
GenericBase<String> cleanLabel = d2; 

// 触发崩溃
// 引用声明它是 String，JVM 尝试进行隐式转换。
// 实际对象是 Integer -> 抛出 ClassCastException
String water = cleanLabel.get(); 
```

#### 总结：未检查调用的风险

1. **方法签名退化**：由于 `d2` 是原生类型，`set(T)` 退化为 `set(Object)`，失去了泛型约束。
2. **合法的错误插入**：编译器不再检查传入参数的类型，允许将 `Integer` 存入本该是泛型的容器。逻辑约束被破坏，但符合语法规则。
3. **隐蔽的运行时异常**：警告是编译器的“免责声明”。它表明编译器无法验证数据的类型正确性。如果你忽视此警告，程序极有可能在未来的某个时间点（读取数据时）抛出 `ClassCastException`。

---

## 3. 标记 [3]：通配符的继承限制 (Wildcard Inheritance)

```java
// [3] Strange error:
//   unexpected type
//   required: class or interface without bounds
//   found:    ?
// 意外的类型；发现了：?（通配符）；需要：无边界的类或接口
// 编译器拒绝不确定的通配符作为父类，必须指定具体的泛型参数如 <String>，或者使用原始类型
// class Derived3 extends GenericBase<?> {
// }
```

#### 错误原因分析

此错误源于 Java 继承机制对**父类确定性（Supertype Determinism）**的严格要求。

**1. 继承（extends）的本质：契约的确定性**

* **类定义的基石**：子类（Subclass）继承父类（Superclass），意味着子类必须全盘接收并可能扩展父类的接口契约（Interface Contract）。父类的结构（包括方法签名、字段类型）必须在编译时是确定的。
* **合法继承示例**：
* `extends GenericBase<String>`：父类明确为“存储 String 的容器”。子类清楚 `get()` 方法返回 `String`，`set()` 接收 `String`。
* `extends GenericBase`（原生）：父类明确为“存储 Object 的容器”（尽管不安全）。子类清楚 `get()` 方法返回 `Object`。

**2. 通配符 `?` 的本质：类型的不确定性**

* **语义**：`GenericBase<?>` 表示“一个持有某种特定类型、但具体类型未知的容器”。
* **逻辑悖论**：如果在继承子句中使用通配符（如 `extends GenericBase<?>`），会导致父类契约无法确定。

**3. 具体的逻辑矛盾**

如果允许 `class Derived3 extends GenericBase<?>`，编译器将无法确定父类的方法签名，从而导致子类无法构建：

* **方法返回类型的二义性**：父类的 `get()` 方法应该返回什么？虽然在读取时可以安全地视为 `Object`，但在类型语义上它是“未知的”。
* **重写（Override）的死局**：子类如果试图重写父类的方法，参数类型该怎么写？
* `set(Object)`？不对，父类可能是 `set(String)`。
* `set(String)`？不对，父类可能是 `set(Integer)`。
* 这种不确定性导致子类无法构建稳定的**虚方法表（vtable）**和内存布局。

为了防止这种逻辑混乱，Java 语言规范明确禁止将带有通配符 `?` 的泛型作为直接父类。

**解决方案**：要么指定具体的类型（如 `String`），要么传递泛型参数（如 `class Derived3<T> extends GenericBase<T>`），要么（不推荐地）放弃类型安全使用原生类型（如 `Derived2`）。

---

### 深度对比：为什么原生类型允许继承，而 `<?>` 不允许？

这是初学者最容易混淆的两个概念。

#### 1. 原生类型（Raw Type）—— 结构明确，类型不安全

* **写法**：`extends GenericBase`
* **含义**：继承的是经过**类型擦除**后的基类。
* **编译器视角**：父类被视为 `GenericBase<Object>`（但在泛型语义上视为无检查）。它的方法签名在字节码层面是完全确定的（如 `get()` 返回 `Object`）。因此，JVM 可以构建类结构，只是编译器会发出“未检查（Unchecked）”警告。

#### 2. 通配符（Wildcard `?`）—— 结构不明确

* **写法**：`extends GenericBase<?>`
* **含义**：试图继承一个**接口定义处于游离状态**的类型。
* **编译器视角**：`?` 代表未知。一个未知的类型不能作为构建类的地基。这不仅仅是不安全的问题，而是逻辑上的定义缺失。

### 总结对比表

| 特性 | 原生类型 (`Derived2`) | 通配符继承 (`Derived3`) |
| --- | --- | --- |
| **代码形式** | `extends GenericBase` | `extends GenericBase<?>` |
| **编译结果** | **警告 (Warning)** | **错误 (Error)** |
| **父类确定性** | **确定** (退化为 Object) | **不确定** (Unknown Type) |
| **技术本质** | 这是一个**为了兼容性保留的旧类结构**。虽然丧失了泛型安全性，但在运行时结构上是完整的。 | 这是一个**逻辑悖论**。无法确定父类的方法签名契约，因此无法构建子类。 |

---

## 结语：透视 Java 泛型的设计底色

通过对 `ErasureAndInheritance.java` 中三个关键标记的剖析，我们看清了 Java 泛型机制在**兼容性**、**安全性**与**确定性**三者之间的权衡逻辑：

1. **标记 [1] (Warning) 揭示了历史的妥协**：
原生类型（Raw Type）的合法性，是 Java 为了维持迁移兼容性而留下的“后门”。它允许我们将精密的泛型类降级为普通的 `Object` 容器，但这同时也意味着开发者主动放弃了类型系统的保护（撕毁了契约）。
2. **标记 [2] (Warning) 预示了妥协的代价**：
这是**堆污染（Heap Pollution）**的源头。当编译器停止类型检查，错误的类型被允许注入容器。这种“未检查的调用”实质上是在代码中埋下了运行时崩溃（`ClassCastException`）的隐患。
3. **标记 [3] (Error) 划定了语法的底线**：
它捍卫了继承体系的确定性。尽管泛型在使用时可以灵活多变（使用通配符），但在定义类结构时，父类的契约必须是明确的。Java 编译器禁止继承“不确定的类型”，以确保类结构的逻辑自洽。