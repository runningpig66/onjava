* P.540 §17.4 监听 Path

**在 TreeWatcher.java 示例中，为什么监听线程（子线程）和事件触发线程（主线程）的角色与 PathWatcher.java 示例完全相反？这种设计如何解决了单层目录监听的限制？**

------

你的观察非常敏锐，分析也**完全正确**！这份 `TreeWatcher` 代码的架构确实与昨天的 `PathWatcher` 发生了**“镜像反转”**。我们来逐一拆解你的两个问题。

### 1. 关于 `submit` 方法
```java
Executors.newSingleThreadExecutor().submit(() -> { ... });
```
- **作用**：`submit` 会**立即**将一个任务（Runnable）提交到线程池排队执行。它没有 `schedule` 那样的延迟参数。
- **关键**：在这个例子中，提交的任务里**第一行就是 `watcher.take()`**。因此，子线程被创建后几乎会**立刻执行到 `take()` 并进入阻塞等待状态**。所以，从效果上看，它与昨天的 `schedule`（延迟后执行）虽然触发方式不同，但都让**一个线程进入了“等待事件”的状态**。

### 2. 关于线程角色与程序架构
你的理解完全正确，这正是本示例最精妙的设计。我们来对比一下：

| 方面           | **昨天的 `PathWatcher`**                    | **今天的 `TreeWatcher`**                                     |
| :------------- | :------------------------------------------ | :----------------------------------------------------------- |
| **监听目标**   | 仅顶层 `test` 目录。                        | **整个目录树**的每一个子目录（通过`walk`+`forEach`）。       |
| **阻塞者**     | **主线程**在 `take()` 处阻塞。              | **为每个子目录创建的单独子线程**在各自的 `take()` 处阻塞。   |
| **事件触发者** | **子线程**（延迟250ms后删除文件）。         | **主线程**（直接调用 `PathWatcher.delTxtFiles()`）。         |
| **核心目的**   | 演示 `WatchService` 基本的“等待-通知”机制。 | 演示如何**监听整个目录树**（为每个子目录独立设置监听）。     |
| **程序结束**   | 主线程被一个事件唤醒后，打印信息并退出。    | 任何一个子线程被事件唤醒后，打印信息并调用 `System.exit(0)` 结束**整个程序**。 |

### 🔄 新代码的完整流程梳理

1.  **主线程**：调用 `Files.walk(...).forEach(...)`，为 `test` 目录下的**每一个子目录**（包括自身）都执行一次 `watchDir` 方法。
2.  **创建监听子线程**：每调用一次 `watchDir`，就会：
    a. 为该目录创建一个新的 `WatchService`。
    b. 注册监听 `ENTRY_DELETE` 事件。
    c. **提交一个任务到新线程**，该任务的核心就是 `watcher.take()`。
3.  **子线程阻塞**：每个被创建出来的子线程，执行到各自的 `watcher.take()` 时，**立刻进入阻塞状态**，等待自己负责的那个目录发生删除事件。
4.  **主线程触发事件**：当所有目录的监听子线程都启动并进入等待后，主线程才执行最后的 `PathWatcher.delTxtFiles()`。这个方法会**递归删除整个目录树下所有 `.txt` 文件**。
5.  **子线程被唤醒并结束程序**：当文件被删除时，其所在目录对应的那个子线程会收到事件，从 `take()` 中返回，打印日志，然后执行 `System.exit(0)`。**一旦有一个子线程执行了 `System.exit(0)`，整个JVM进程就会终止**，所有其他还在等待的子线程也会被强行结束。

### 💎 总结与核心要点

- **架构反转**：你准确地抓住了从“**主等子触发**”到“**子等主触发**”的转变。
- **解决核心问题**：这个反转正是为了解决书中强调的 “**WatchService只监听单层目录**” 的限制。通过**为每个子目录分配独立的监听线程**，实现了对整棵目录树的监控。
- **一个潜在问题**：由于多个子线程可能几乎同时收到事件并执行 `System.exit(0)`，这可能会导致输出信息不完整或产生竞争条件，但这对于演示核心概念而言是可以接受的。

这个示例巧妙地展示了如何将简单的工具（单目录监听）组合起来解决复杂需求（全目录树监听），是理解如何用多线程和WatchService构建实用工具的优秀案例。
