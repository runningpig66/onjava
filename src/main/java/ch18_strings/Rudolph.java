package ch18_strings;

/**
 * @author runningpig66
 * @date 2025/12/13 周六
 * @time 17:34
 * P.570 §18.7 正则表达式 §18.7.2 创建正则表达式
 * <p>
 * ============================================================
 * 构造项                         生成结果
 * ------------------------------------------------------------
 * B                             指定字符 B
 * \xhh                          具有十六进制值 0xhh 的字符
 * \ uhhhh                       十六进制表示为 0xhhhh 的 Unicode 字符
 * \t                            制表符 (Tab)
 * \n                            换行
 * \r                            回车
 * \f                            换页
 * \e                            转义 (escape)
 * ============================================================
 * 符 号                         结 果
 * ------------------------------------------------------------
 * .                             任何字符
 * [abc]                         a、b 或 c 中的任何一个字符（与 a|b|c 相同）
 * [^abc]                        a、b 或 c 之外的任何字符（否定）
 * [a-zA-Z]                      a~z 或 A~Z 的任何字符（范围）
 * [abc[hij]]                    a、b、c、h、i、j 中的任何一个字符（与 a|b|c|h|i|j 相同，求并集）
 * [a-z&&[hij]]                  h、i 或 j 中的任何一个字符（求交集）
 * \s                            一个空白字符（空格、制表符、换行符、换页、回车）
 * \S                            非空白字符（[^\s]）
 * \d                            数字（[0-9]）
 * \D                            非数字（[^0-9]）
 * \w                            一个单词字符（[a-zA-Z_0-9]）
 * \W                            一个非单词字符（[^\w]）
 * ============================================================
 * 逻辑操作符                     含  义
 * ------------------------------------------------------------
 * XY                            X 后跟 Y
 * X|Y                           X 或 Y
 * (X)                           一个捕获组（capturing group）。你可以在后面的表达式中用 \i 来引用第 i 个捕获组
 * ============================================================
 * 边界匹配器                     含  义
 * ------------------------------------------------------------
 * ^                             行首
 * $                             行尾
 * \b                            单词的边界
 * \B                            非单词的边界
 * \G                            前一个匹配的结束
 * ===================== 量词 Quantifiers ======================
 * 贪婪型 greedy     勉强型 reluctant   占有型 possessive   匹 配
 * ------------------------------------------------------------
 * X?               X??               X?+                X，一个或一个没有
 * X*               X*?               X*+                X，零个或多个
 * X+               X+?               X++                X，一个或多个
 * X{n}             X{n}?             X{n}+              X，正好 n 个
 * X{n,}            X{n,}?            X{n,}+             X，至少 n 个
 * X{n,m}           X{n,m}?           X{n,m}+            X，至少 n 个但不超过 m 个
 * ============================================================
 * <p>
 * 例如，下面的每个正则表达式都能成功匹配字符序列 "Rudolph"：
 * 你的目标不应该是创建最难理解的正则表达式，而应该是创建能完成工作的最简单的正则表达式。
 * 在编写新的正则表达式时，你会发现自己经常需要参考旧的代码。
 */
public class Rudolph {
    public static void main(String[] args) {
        for (String pattern : new String[]{
                // 精确匹配字符串 "Rudolph"
                "Rudolph",
                // 匹配以 'r' 或 'R' 开头，后跟 "udolph"
                "[rR]udolph",
                // 匹配: 'r'或'R' + 一个元音字母 + 一个 a 到 z 的小写字母 + "ol" + 任意字符零次或多次
                "[rR][aeiou][a-z]ol.*",
                // 匹配以 'R' 开头，后跟任意字符零次或多次
                "R.*"}) {
            System.out.println("Rudolph".matches(pattern));
        }
    }
}
/* Output:
true
true
true
true
 */
